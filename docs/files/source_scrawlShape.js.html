<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>source\scrawlShape.js - scrawl-canvas</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="scrawl-canvas"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 4.2.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Action.html">Action</a></li>
            
                <li><a href="../classes/Animation.html">Animation</a></li>
            
                <li><a href="../classes/Base.html">Base</a></li>
            
                <li><a href="../classes/Block.html">Block</a></li>
            
                <li><a href="../classes/BlurFilter.html">BlurFilter</a></li>
            
                <li><a href="../classes/BrightnessFilter.html">BrightnessFilter</a></li>
            
                <li><a href="../classes/Cell.html">Cell</a></li>
            
                <li><a href="../classes/ChannelsFilter.html">ChannelsFilter</a></li>
            
                <li><a href="../classes/ChannelStepFilter.html">ChannelStepFilter</a></li>
            
                <li><a href="../classes/Color.html">Color</a></li>
            
                <li><a href="../classes/Context.html">Context</a></li>
            
                <li><a href="../classes/Design.html">Design</a></li>
            
                <li><a href="../classes/Element.html">Element</a></li>
            
                <li><a href="../classes/ElementGroup.html">ElementGroup</a></li>
            
                <li><a href="../classes/Entity.html">Entity</a></li>
            
                <li><a href="../classes/Filter.html">Filter</a></li>
            
                <li><a href="../classes/Force.html">Force</a></li>
            
                <li><a href="../classes/Gradient.html">Gradient</a></li>
            
                <li><a href="../classes/GreyscaleFilter.html">GreyscaleFilter</a></li>
            
                <li><a href="../classes/Group.html">Group</a></li>
            
                <li><a href="../classes/Image.html">Image</a></li>
            
                <li><a href="../classes/InvertFilter.html">InvertFilter</a></li>
            
                <li><a href="../classes/LeachFilter.html">LeachFilter</a></li>
            
                <li><a href="../classes/Link.html">Link</a></li>
            
                <li><a href="../classes/MatrixFilter.html">MatrixFilter</a></li>
            
                <li><a href="../classes/NoiseFilter.html">NoiseFilter</a></li>
            
                <li><a href="../classes/Pad.html">Pad</a></li>
            
                <li><a href="../classes/PageElement.html">PageElement</a></li>
            
                <li><a href="../classes/Particle.html">Particle</a></li>
            
                <li><a href="../classes/Path.html">Path</a></li>
            
                <li><a href="../classes/Pattern.html">Pattern</a></li>
            
                <li><a href="../classes/Phrase.html">Phrase</a></li>
            
                <li><a href="../classes/Picture.html">Picture</a></li>
            
                <li><a href="../classes/PixelateFilter.html">PixelateFilter</a></li>
            
                <li><a href="../classes/Point.html">Point</a></li>
            
                <li><a href="../classes/Position.html">Position</a></li>
            
                <li><a href="../classes/Quaternion.html">Quaternion</a></li>
            
                <li><a href="../classes/RadialGradient.html">RadialGradient</a></li>
            
                <li><a href="../classes/SaturationFilter.html">SaturationFilter</a></li>
            
                <li><a href="../classes/Shape.html">Shape</a></li>
            
                <li><a href="../classes/Spring.html">Spring</a></li>
            
                <li><a href="../classes/SpriteAnimation.html">SpriteAnimation</a></li>
            
                <li><a href="../classes/Stack.html">Stack</a></li>
            
                <li><a href="../classes/StereoFilter.html">StereoFilter</a></li>
            
                <li><a href="../classes/Text.html">Text</a></li>
            
                <li><a href="../classes/ThresholdFilter.html">ThresholdFilter</a></li>
            
                <li><a href="../classes/Timeline.html">Timeline</a></li>
            
                <li><a href="../classes/TintFilter.html">TintFilter</a></li>
            
                <li><a href="../classes/Tween.html">Tween</a></li>
            
                <li><a href="../classes/Vector.html">Vector</a></li>
            
                <li><a href="../classes/Video.html">Video</a></li>
            
                <li><a href="../classes/Wheel.html">Wheel</a></li>
            
                <li><a href="../classes/window.scrawl.html">window.scrawl</a></li>
            
                <li><a href="../classes/window.scrawl_Animation.html">window.scrawl_Animation</a></li>
            
                <li><a href="../classes/window.scrawl_Block.html">window.scrawl_Block</a></li>
            
                <li><a href="../classes/window.scrawl_Collisions.html">window.scrawl_Collisions</a></li>
            
                <li><a href="../classes/window.scrawl_Color.html">window.scrawl_Color</a></li>
            
                <li><a href="../classes/window.scrawl_Factories.html">window.scrawl_Factories</a></li>
            
                <li><a href="../classes/window.scrawl_Filters.html">window.scrawl_Filters</a></li>
            
                <li><a href="../classes/window.scrawl_Images.html">window.scrawl_Images</a></li>
            
                <li><a href="../classes/window.scrawl_Path.html">window.scrawl_Path</a></li>
            
                <li><a href="../classes/window.scrawl_Phrase.html">window.scrawl_Phrase</a></li>
            
                <li><a href="../classes/window.scrawl_Physics.html">window.scrawl_Physics</a></li>
            
                <li><a href="../classes/window.scrawl_SaveLoad.html">window.scrawl_SaveLoad</a></li>
            
                <li><a href="../classes/window.scrawl_Shape.html">window.scrawl_Shape</a></li>
            
                <li><a href="../classes/window.scrawl_Stacks.html">window.scrawl_Stacks</a></li>
            
                <li><a href="../classes/window.scrawl_Wheel.html">window.scrawl_Wheel</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/scrawlAnimation.html">scrawlAnimation</a></li>
            
                <li><a href="../modules/scrawlBlock.html">scrawlBlock</a></li>
            
                <li><a href="../modules/scrawlCollisions.html">scrawlCollisions</a></li>
            
                <li><a href="../modules/scrawlColor.html">scrawlColor</a></li>
            
                <li><a href="../modules/scrawlCore.html">scrawlCore</a></li>
            
                <li><a href="../modules/scrawlFilters.html">scrawlFilters</a></li>
            
                <li><a href="../modules/scrawlImages.html">scrawlImages</a></li>
            
                <li><a href="../modules/scrawlPath.html">scrawlPath</a></li>
            
                <li><a href="../modules/scrawlPathFactories.html">scrawlPathFactories</a></li>
            
                <li><a href="../modules/scrawlPhrase.html">scrawlPhrase</a></li>
            
                <li><a href="../modules/scrawlPhysics.html">scrawlPhysics</a></li>
            
                <li><a href="../modules/scrawlSaveLoad.html">scrawlSaveLoad</a></li>
            
                <li><a href="../modules/scrawlShape.html">scrawlShape</a></li>
            
                <li><a href="../modules/scrawlStacks.html">scrawlStacks</a></li>
            
                <li><a href="../modules/scrawlWheel.html">scrawlWheel</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: source\scrawlShape.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
//---------------------------------------------------------------------------------
// The MIT License (MIT)
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//---------------------------------------------------------------------------------

/**
# scrawlShape

## Purpose and features

The Shape module adds Shape entitys - path-based objects - to the core module

* Defines a entity composed of lines, quadratic and bezier curves, etc
* See also Path object, which achieves a similar thing in a different way

@module scrawlShape
**/

if (window.scrawl &amp;&amp; window.scrawl.modules &amp;&amp; !window.scrawl.contains(window.scrawl.modules, &#x27;shape&#x27;)) {
	var scrawl = (function(my) {
		&#x27;use strict&#x27;;

		/**
# window.scrawl

scrawlShape module adaptions to the Scrawl library object

@class window.scrawl_Shape
**/

		/**
Alias for makeShape()
@method newShape
@deprecated
**/
		my.newShape = function(items) {
			return my.makeShape(items);
		};
		/**
A __factory__ function to generate new Shape entitys
@method makeShape
@param {Object} items Key:value Object argument for setting attributes
@return Shape object
@example
	scrawl.makeShape({
		startX: 50,
		startY: 20,
		fillStyle: &#x27;red&#x27;,
		data: &#x27;M0,0 50,0 60,20, 10,20 0,0z&#x27;,
		});
**/
		my.makeShape = function(items) {
			return new my.Shape(items);
		};

		/**
# Shape

## Instantiation

* scrawl.makeShape() - Irregular, path-based shapes

Additional factory functions to instantiate Shape objects are available in the __pathFactoryFunctions__ module

## Purpose

* Defines a entity composed of lines, quadratic and bezier curves, etc
* See also Path object, which achieves a similar thing in a different way

## Access

* scrawl.entity.SHAPENAME - for the Shape entity object

@class Shape
@constructor
@extends Entity
@param {Object} [items] Key:value Object argument for setting attributes
**/
		my.Shape = function Shape(items) {
			items = (my.isa(items, &#x27;obj&#x27;)) ? items : {};
			my.Entity.call(this, items);
			my.Position.prototype.set.call(this, items);
			this.isLine = (my.isa(items.isLine, &#x27;bool&#x27;)) ? items.isLine : true;
			this.dataSet = (my.xt(this.data)) ? this.buildDataSet(this.data) : &#x27;&#x27;;
			this.registerInLibrary();
			my.pushUnique(my.group[this.group].entitys, this.name);
			return this;
		};
		my.Shape.prototype = Object.create(my.Entity.prototype);
		/**
@property type
@type String
@default &#x27;Shape&#x27;
@final
**/
		my.Shape.prototype.type = &#x27;Shape&#x27;;
		my.Shape.prototype.classname = &#x27;entitynames&#x27;;
		my.d.Shape = {
			/**
Interpreted path data - calculated by scrawl from the data attribute
@property dataSet
@type Array
@default false
@private
**/
			dataSet: false,
			/**
Drawing flag - when set to true, will treat the first drawing (not positioning) data point as the start point

Generally this is set automatically as part of a shape factory function
@property isLine
@type Boolean
@default true
**/
			isLine: true,
			/**
Shape entity default method attribute is &#x27;draw&#x27;, not &#x27;fill&#x27;
@property method
@type String
@default &#x27;draw&#x27;
**/
			method: &#x27;draw&#x27;,
		};
		my.mergeInto(my.d.Shape, my.d.Entity);
		/**
Augments Entity.set()
@method set
@param {Object} items Object consisting of key:value attributes
@return This
@chainable
**/
		my.Shape.prototype.set = function(items) {
			my.Entity.prototype.set.call(this, items);
			items = (my.isa(items, &#x27;obj&#x27;)) ? items : {};
			if (my.xt(items.data)) {
				this.dataSet = this.buildDataSet(this.data);
				this.offset.flag = false;
			}
			return this;
		};
		/**
Augments Position.getPivotOffsetVector()
@method getPivotOffsetVector
@return A Vector of calculated offset values to help determine where entity drawing should start
@private
**/
		my.Shape.prototype.getPivotOffsetVector = function() {
			return (this.isLine) ? my.Entity.prototype.getPivotOffsetVector.call(this) : this.getCenteredPivotOffsetVector();
		};
		/**
Constructor, clone and set helper function

Create native path data from data attribute String

@method buildDataSet
@param {String} d Path string
@return Native path data
@private
**/
		my.Shape.prototype.buildDataSet = function(d) {
			var stat1 = [&#x27;M&#x27;, &#x27;L&#x27;, &#x27;C&#x27;, &#x27;Q&#x27;, &#x27;S&#x27;, &#x27;T&#x27;],
				myData = [],
				command,
				points = [],
				minX,
				minY,
				maxX,
				maxY,
				curX,
				curY,
				set,
				i,
				iz,
				j,
				jz,
				result = [];
			myData.length = 0;
			minX = 999999;
			minY = 999999;
			maxX = -999999;
			maxY = -999999;
			curX = this.start.x;
			curY = this.start.y;
			set = d.match(/([A-Za-z][0-9. ,\-]*)/g);
			var checkMaxMin = function(cx, cy) {
				minX = (minX &gt; cx) ? cx : minX;
				minY = (minY &gt; cy) ? cy : minY;
				maxX = (maxX &lt; cx) ? cx : maxX;
				maxY = (maxY &lt; cy) ? cy : maxY;
			};
			for (i = 0, iz = set.length; i &lt; iz; i++) {
				command = set [i][0];
				points = set [i].match(/(-?[0-9.]+\b)/g);
				if (points) {
					for (j = 0, jz = points.length; j &lt; jz; j++) {
						points[j] = parseFloat(points[j]);
					}
					switch (command) {
						case &#x27;H&#x27;:
							for (j = 0, jz = points.length; j &lt; jz; j++) {
								curX = points[j];
								checkMaxMin(curX, curY);
							}
							break;
						case &#x27;V&#x27;:
							for (j = 0, jz = points.length; j &lt; jz; j++) {
								curY = points[j];
								checkMaxMin(curX, curY);
							}
							break;
						case &#x27;M&#x27;:
							for (j = 0, jz = points.length; j &lt; jz; j += 2) {
								curX = points[j];
								curY = points[j + 1];
								checkMaxMin(curX, curY);
							}
							break;
						case &#x27;L&#x27;:
						case &#x27;T&#x27;:
							for (j = 0, jz = points.length; j &lt; jz; j += 2) {
								curX = points[j];
								curY = points[j + 1];
								checkMaxMin(curX, curY);
							}
							break;
						case &#x27;Q&#x27;:
						case &#x27;S&#x27;:
							for (j = 0, jz = points.length; j &lt; jz; j += 4) {
								curX = points[j + 2];
								curY = points[j + 3];
								checkMaxMin(curX, curY);
							}
							break;
						case &#x27;C&#x27;:
							for (j = 0, jz = points.length; j &lt; jz; j += 6) {
								curX = points[j + 4];
								curY = points[j + 5];
								checkMaxMin(curX, curY);
							}
							break;
						case &#x27;h&#x27;:
							for (j = 0, jz = points.length; j &lt; jz; j++) {
								curX += points[j];
								checkMaxMin(curX, curY);
							}
							break;
						case &#x27;v&#x27;:
							for (j = 0, jz = points.length; j &lt; jz; j++) {
								curY += points[j];
								checkMaxMin(curX, curY);
							}
							break;
						case &#x27;m&#x27;:
						case &#x27;l&#x27;:
						case &#x27;t&#x27;:
							for (j = 0, jz = points.length; j &lt; jz; j += 2) {
								curX += points[j];
								curY += points[j + 1];
								checkMaxMin(curX, curY);
							}
							break;
						case &#x27;q&#x27;:
						case &#x27;s&#x27;:
							for (j = 0, jz = points.length; j &lt; jz; j += 4) {
								curX += points[j + 2];
								curY += points[j + 3];
								checkMaxMin(curX, curY);
							}
							break;
						case &#x27;c&#x27;:
							for (j = 0, jz = points.length; j &lt; jz; j += 6) {
								curX += points[j + 4];
								curY += points[j + 5];
								checkMaxMin(curX, curY);
							}
							break;
					}
				}
				myData.push({
					c: command,
					p: points
				});
			}
			for (i = 0, iz = myData.length; i &lt; iz; i++) {
				if (my.contains(stat1, myData[i].c)) {
					for (j = 0, jz = myData[i].p.length; j &lt; jz; j += 2) {
						myData[i].p[j] -= minX;
						myData[i].p[j + 1] -= minY;
					}
				}
				if (myData[i].c === &#x27;H&#x27;) {
					for (j = 0, jz = myData[i].p.length; j &lt; jz; j++) {
						myData[i].p[j] -= minX;
					}
				}
				if (myData[i].c === &#x27;V&#x27;) {
					for (j = 0, jz = myData[i].p.length; j &lt; jz; j++) {
						myData[i].p[j] -= minY;
					}
				}
			}
			this.width = maxX - minX;
			this.height = maxY - minY;
			for (i = 0, iz = myData.length; i &lt; iz; i++) {
				result.push(myData[i]);
			}
			return result;
		};
		/**
Helper function - define the entity&#x27;s path on the &amp;lt;canvas&amp;gt; element&#x27;s context engine
@method doOutline
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@private
**/
		my.Shape.prototype.doOutline = function(ctx, cell) {
			my.cell[cell].setEngine(this);
			if (!this.dataSet &amp;&amp; this.data) {
				this.buildDataSet(this.data);
			}
			return this.completeOutline(ctx, cell);
		};
		/**
Helper function - define the entity&#x27;s path on the &amp;lt;canvas&amp;gt; element&#x27;s context engine
@method completeOutline
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@return This
@private
**/
		my.Shape.prototype.completeOutline = function(ctx, cell) {
			var stat1 = [&#x27;M&#x27;],
				stat2 = [&#x27;C&#x27;, &#x27;c&#x27;, &#x27;S&#x27;, &#x27;s&#x27;],
				stat3 = [&#x27;Q&#x27;, &#x27;q&#x27;, &#x27;T&#x27;, &#x27;t&#x27;],
				i,
				iz,
				k,
				kz,
				here,
				currentX,
				currentY,
				reflectX,
				reflectY,
				d,
				tempX,
				tempY;
			if (this.dataSet) {
				here = this.prepareStamp();
				currentX = 0;
				currentY = 0;
				reflectX = 0;
				reflectY = 0;
				this.rotateCell(ctx, cell);
				ctx.translate(here.x, here.y);
				ctx.beginPath();
				if (!my.contains(stat1, this.dataSet[0].c)) {
					ctx.moveTo(currentX, currentY);
				}
				for (i = 0, iz = this.dataSet.length; i &lt; iz; i++) {
					d = this.dataSet[i];
					switch (d.c) {
						case &#x27;M&#x27;:
							currentX = d.p[0];
							currentY = d.p[1];
							reflectX = currentX;
							reflectY = currentY;
							ctx.moveTo((currentX * this.scale), (currentY * this.scale));
							for (k = 2, kz = d.p.length; k &lt; kz; k += 2) {
								currentX = d.p[k];
								currentY = d.p[k + 1];
								reflectX = currentX;
								reflectY = currentY;
								ctx.lineTo((currentX * this.scale), (currentY * this.scale));
							}
							break;
						case &#x27;m&#x27;:
							currentX += d.p[0];
							currentY += d.p[1];
							reflectX = currentX;
							reflectY = currentY;
							ctx.moveTo((currentX * this.scale), (currentY * this.scale));
							for (k = 2, kz = d.p.length; k &lt; kz; k += 2) {
								currentX += d.p[k];
								currentY += d.p[k + 1];
								reflectX = currentX;
								reflectY = currentY;
								ctx.lineTo((currentX * this.scale), (currentY * this.scale));
							}
							break;
						case &#x27;Z&#x27;:
						case &#x27;z&#x27;:
							ctx.closePath();
							break;
						case &#x27;L&#x27;:
							for (k = 0, kz = d.p.length; k &lt; kz; k += 2) {
								currentX = d.p[k];
								currentY = d.p[k + 1];
								reflectX = currentX;
								reflectY = currentY;
								ctx.lineTo((currentX * this.scale), (currentY * this.scale));
							}
							break;
						case &#x27;l&#x27;:
							for (k = 0, kz = d.p.length; k &lt; kz; k += 2) {
								currentX += d.p[k];
								currentY += d.p[k + 1];
								reflectX = currentX;
								reflectY = currentY;
								ctx.lineTo((currentX * this.scale), (currentY * this.scale));
							}
							break;
						case &#x27;H&#x27;:
							for (k = 0, kz = d.p.length; k &lt; kz; k++) {
								currentX = d.p[k];
								reflectX = currentX;
								ctx.lineTo((currentX * this.scale), (currentY * this.scale));
							}
							break;
						case &#x27;h&#x27;:
							for (k = 0, kz = d.p.length; k &lt; kz; k++) {
								currentX += d.p[k];
								reflectX = currentX;
								ctx.lineTo((currentX * this.scale), (currentY * this.scale));
							}
							break;
						case &#x27;V&#x27;:
							for (k = 0, kz = d.p.length; k &lt; kz; k++) {
								currentY = d.p[k];
								reflectY = currentY;
								ctx.lineTo((currentX * this.scale), (currentY * this.scale));
							}
							break;
						case &#x27;v&#x27;:
							for (k = 0, kz = d.p.length; k &lt; kz; k++) {
								currentY += d.p[k];
								reflectY = currentY;
								ctx.lineTo((currentX * this.scale), (currentY * this.scale));
							}
							break;
						case &#x27;C&#x27;:
							for (k = 0, kz = d.p.length; k &lt; kz; k += 6) {
								ctx.bezierCurveTo((d.p[k] * this.scale), (d.p[k + 1] * this.scale), (d.p[k + 2] * this.scale), (d.p[k + 3] * this.scale), (d.p[k + 4] * this.scale), (d.p[k + 5] * this.scale));
								reflectX = d.p[k + 2];
								reflectY = d.p[k + 3];
								currentX = d.p[k + 4];
								currentY = d.p[k + 5];
							}
							break;
						case &#x27;c&#x27;:
							for (k = 0, kz = d.p.length; k &lt; kz; k += 6) {
								ctx.bezierCurveTo(((currentX + d.p[k]) * this.scale), ((currentY + d.p[k + 1]) * this.scale), ((currentX + d.p[k + 2]) * this.scale), ((currentY + d.p[k + 3]) * this.scale), ((currentX + d.p[k + 4]) * this.scale), ((currentY + d.p[k + 5]) * this.scale));
								reflectX = currentX + d.p[k + 2];
								reflectY = currentY + d.p[k + 3];
								currentX += d.p[k + 4];
								currentY += d.p[k + 5];
							}
							break;
						case &#x27;S&#x27;:
							for (k = 0, kz = d.p.length; k &lt; kz; k += 4) {
								if (i &gt; 0 &amp;&amp; my.contains(stat2, this.dataSet[i - 1].c)) {
									tempX = currentX + (currentX - reflectX);
									tempY = currentY + (currentY - reflectY);
								}
								else {
									tempX = currentX;
									tempY = currentY;
								}
								ctx.bezierCurveTo((tempX * this.scale), (tempY * this.scale), (d.p[k] * this.scale), (d.p[k + 1] * this.scale), (d.p[k + 2] * this.scale), (d.p[k + 3] * this.scale));
								reflectX = d.p[k];
								reflectY = d.p[k + 1];
								currentX = d.p[k + 2];
								currentY = d.p[k + 3];
							}
							break;
						case &#x27;s&#x27;:
							for (k = 0, kz = d.p.length; k &lt; kz; k += 4) {
								if (i &gt; 0 &amp;&amp; my.contains(stat2, this.dataSet[i - 1].c)) {
									tempX = currentX + (currentX - reflectX);
									tempY = currentY + (currentY - reflectY);
								}
								else {
									tempX = currentX;
									tempY = currentY;
								}
								ctx.bezierCurveTo((tempX * this.scale), (tempY * this.scale), ((currentX + d.p[k]) * this.scale), ((currentY + d.p[k + 1]) * this.scale), ((currentX + d.p[k + 2]) * this.scale), ((currentY + d.p[k + 3]) * this.scale));
								reflectX = currentX + d.p[k];
								reflectY = currentY + d.p[k + 1];
								currentX += d.p[k + 2];
								currentY += d.p[k + 3];
							}
							break;
						case &#x27;Q&#x27;:
							for (k = 0, kz = d.p.length; k &lt; kz; k += 4) {
								ctx.quadraticCurveTo((d.p[k] * this.scale), (d.p[k + 1] * this.scale), (d.p[k + 2] * this.scale), (d.p[k + 3] * this.scale));
								reflectX = d.p[k];
								reflectY = d.p[k + 1];
								currentX = d.p[k + 2];
								currentY = d.p[k + 3];
							}
							break;
						case &#x27;q&#x27;:
							for (k = 0, kz = d.p.length; k &lt; kz; k += 4) {
								ctx.quadraticCurveTo(((currentX + d.p[k]) * this.scale), ((currentY + d.p[k + 1]) * this.scale), ((currentX + d.p[k + 2]) * this.scale), ((currentY + d.p[k + 3]) * this.scale));
								reflectX = currentX + d.p[k];
								reflectY = currentY + d.p[k + 1];
								currentX += d.p[k + 2];
								currentY += d.p[k + 3];
							}
							break;
						case &#x27;T&#x27;:
							for (k = 0, kz = d.p.length; k &lt; kz; k += 2) {
								if (i &gt; 0 &amp;&amp; my.contains(stat3, this.dataSet[i - 1].c)) {
									tempX = currentX + (currentX - reflectX);
									tempY = currentY + (currentY - reflectY);
								}
								else {
									tempX = currentX;
									tempY = currentY;
								}
								ctx.quadraticCurveTo((tempX * this.scale), (tempY * this.scale), (d.p[k] * this.scale), (d.p[k + 1] * this.scale));
								reflectX = tempX;
								reflectY = tempY;
								currentX = d.p[k];
								currentY = d.p[k + 1];
							}
							break;
						case &#x27;t&#x27;:
							for (k = 0, kz = d.p.length; k &lt; kz; k += 2) {
								if (i &gt; 0 &amp;&amp; my.contains(stat3, this.dataSet[i - 1].c)) {
									tempX = currentX + (currentX - reflectX);
									tempY = currentY + (currentY - reflectY);
								}
								else {
									tempX = currentX;
									tempY = currentY;
								}
								ctx.quadraticCurveTo((tempX * this.scale), (tempY * this.scale), ((currentX + d.p[k]) * this.scale), ((currentY + d.p[k + 1]) * this.scale));
								reflectX = tempX;
								reflectY = tempY;
								currentX += d.p[k];
								currentY += d.p[k + 1];
							}
							break;
					}
				}
			}
			return this;
		};
		/**
Stamp helper function - perform a &#x27;clip&#x27; method draw
@method clip
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Shape.prototype.clip = function(ctx, cell) {
			ctx.save();
			this.doOutline(ctx, cell);
			ctx.clip();
			return this;
		};
		/**
Stamp helper function - perform a &#x27;clear&#x27; method draw
@method clear
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Shape.prototype.clear = function(ctx, cell) {
			cell = my.cell[cell];
			this.clip(ctx, cell);
			ctx.clearRect(0, 0, cell.get(&#x27;actualWidth&#x27;), cell.get(&#x27;.actualHeight&#x27;));
			ctx.restore();
			return this;
		};
		/**
Stamp helper function - perform a &#x27;clearWithBackground&#x27; method draw
@method clearWithBackground
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Shape.prototype.clearWithBackground = function(ctx, cell) {
			cell = my.cell[cell];
			this.clip(ctx, cell);
			ctx.fillStyle = c.backgroundColor;
			ctx.fillRect(0, 0, cell.get(&#x27;actualWidth&#x27;), cell.get(&#x27;actualHeight&#x27;));
			ctx.fillStyle = my.ctx[cell].get(&#x27;fillStyle&#x27;);
			ctx.restore();
			return this;
		};
		/**
Stamp helper function - perform a &#x27;draw&#x27; method draw
@method draw
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Shape.prototype.draw = function(ctx, cell) {
			this.doOutline(ctx, cell);
			ctx.stroke();
			return this;
		};
		/**
Stamp helper function - perform a &#x27;fill&#x27; method draw
@method fill
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Shape.prototype.fill = function(ctx, cell) {
			this.doOutline(ctx, cell);
			ctx.fill(my.ctx[this.context].get(&#x27;winding&#x27;));
			return this;
		};
		/**
Stamp helper function - perform a &#x27;drawFill&#x27; method draw
@method drawFill
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Shape.prototype.drawFill = function(ctx, cell) {
			this.doOutline(ctx, cell);
			ctx.stroke();
			this.clearShadow(ctx, cell);
			ctx.fill(my.ctx[this.context].get(&#x27;winding&#x27;));
			return this;
		};
		/**
Stamp helper function - perform a &#x27;fillDraw&#x27; method draw
@method fillDraw
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Shape.prototype.fillDraw = function(ctx, cell) {
			this.doOutline(ctx, cell);
			ctx.fill(my.ctx[this.context].get(&#x27;winding&#x27;));
			this.clearShadow(ctx, cell);
			ctx.stroke();
			return this;
		};
		/**
Stamp helper function - perform a &#x27;sinkInto&#x27; method draw
@method sinkInto
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Shape.prototype.sinkInto = function(ctx, cell) {
			this.doOutline(ctx, cell);
			ctx.fill(my.ctx[this.context].get(&#x27;winding&#x27;));
			ctx.stroke();
			return this;
		};
		/**
Stamp helper function - perform a &#x27;floatOver&#x27; method draw
@method floatOver
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Shape.prototype.floatOver = function(ctx, cell) {
			this.doOutline(ctx, cell);
			ctx.stroke();
			ctx.fill(my.ctx[this.context].get(&#x27;winding&#x27;));
			return this;
		};
		/**
Stamp helper function - perform a &#x27;none&#x27; method draw
@method none
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Shape.prototype.none = function(ctx, cell) {
			this.doOutline(ctx, cell);
			return this;
		};
		/**
Check Cell coordinates to see if any of them fall within this entity&#x27;s path - uses JavaScript&#x27;s _isPointInPath_ function

Argument object contains the following attributes:

* __tests__ - an array of Vector coordinates to be checked; alternatively can be a single Vector
* __x__ - X coordinate
* __y__ - Y coordinate

Either the &#x27;tests&#x27; attribute should contain a Vector, or an array of vectors, or the x and y attributes should be set to Number values
@method checkHit
@param {Object} items Argument object
@return The first coordinate to fall within the entity&#x27;s path; false if none fall within the path
**/
		my.Shape.prototype.checkHit = function(items) {
			var tests,
				result,
				winding,
				i,
				iz;
			items = (my.isa(items, &#x27;obj&#x27;)) ? items : {};
			tests = (my.xt(items.tests)) ? [].concat(items.tests) : [(items.x || false), (items.y || false)];
			result = false;
			winding = my.ctx[this.context].winding;
			my.cvx.mozFillRule = winding;
			my.cvx.msFillRule = winding;
			this.completeOutline(my.cvx, my.group[this.group].cell);
			for (i = 0, iz = tests.length; i &lt; iz; i += 2) {
				result = my.cvx.isPointInPath(tests[i], tests[i + 1]);
				if (result) {
					items.x = tests[i];
					items.y = tests[i + 1];
					break;
				}
			}
			return (result) ? items : false;
		};
		/**
Collision detection helper function

Parses the collisionPoints array to generate coordinate Vectors representing the entity&#x27;s collision points
@method buildCollisionVectors
@param {Array} [items] Array of collision point data
@return This
@chainable
@private
**/
		my.Shape.prototype.buildCollisionVectors = function(items) {
			var i,
				iz,
				p,
				o,
				w,
				h;
			if (this.isLine) {
				my.Entity.prototype.buildCollisionVectors.call(this, items);
			}
			else {
				p = (my.xt(items)) ? this.parseCollisionPoints(items) : this.collisionPoints;
				o = this.getOffsetStartVector().reverse();
				w = this.width / 2;
				h = this.height / 2;
				this.collisionVectors.length = 0;
				for (i = 0, iz = p.length; i &lt; iz; i++) {
					if (my.isa(p[i], &#x27;str&#x27;)) {
						switch (p[i]) {
							case &#x27;start&#x27;:
								this.collisionVectors.push(0);
								this.collisionVectors.push(0);
								break;
							case &#x27;N&#x27;:
								this.collisionVectors.push(-o.x);
								this.collisionVectors.push(-h - o.y);
								break;
							case &#x27;NE&#x27;:
								this.collisionVectors.push(w - o.x);
								this.collisionVectors.push(-h - o.y);
								break;
							case &#x27;E&#x27;:
								this.collisionVectors.push(w - o.x);
								this.collisionVectors.push(-o.y);
								break;
							case &#x27;SE&#x27;:
								this.collisionVectors.push(w - o.x);
								this.collisionVectors.push(h - o.y);
								break;
							case &#x27;S&#x27;:
								this.collisionVectors.push(-o.x);
								this.collisionVectors.push(h - o.y);
								break;
							case &#x27;SW&#x27;:
								this.collisionVectors.push(-w - o.x);
								this.collisionVectors.push(h - o.y);
								break;
							case &#x27;W&#x27;:
								this.collisionVectors.push(-w - o.x);
								this.collisionVectors.push(-o.y);
								break;
							case &#x27;NW&#x27;:
								this.collisionVectors.push(-w - o.x);
								this.collisionVectors.push(-h - o.y);
								break;
							case &#x27;center&#x27;:
								this.collisionVectors.push(-o.x);
								this.collisionVectors.push(-o.y);
								break;
						}
					}
					else if (my.isa(p[i], &#x27;vector&#x27;)) {
						this.collisionVectors.push(p[i].x);
						this.collisionVectors.push(p[i].y);
					}
				}
			}
			return this;
		};

		return my;
	}(scrawl));
}

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
