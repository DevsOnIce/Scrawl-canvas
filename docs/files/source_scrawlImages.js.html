<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>source\scrawlImages.js - scrawl-canvas</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="scrawl-canvas"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 4.2.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Action.html">Action</a></li>
            
                <li><a href="../classes/Animation.html">Animation</a></li>
            
                <li><a href="../classes/Base.html">Base</a></li>
            
                <li><a href="../classes/Block.html">Block</a></li>
            
                <li><a href="../classes/BlurFilter.html">BlurFilter</a></li>
            
                <li><a href="../classes/BrightnessFilter.html">BrightnessFilter</a></li>
            
                <li><a href="../classes/Cell.html">Cell</a></li>
            
                <li><a href="../classes/ChannelsFilter.html">ChannelsFilter</a></li>
            
                <li><a href="../classes/ChannelStepFilter.html">ChannelStepFilter</a></li>
            
                <li><a href="../classes/Color.html">Color</a></li>
            
                <li><a href="../classes/Context.html">Context</a></li>
            
                <li><a href="../classes/Design.html">Design</a></li>
            
                <li><a href="../classes/Element.html">Element</a></li>
            
                <li><a href="../classes/ElementGroup.html">ElementGroup</a></li>
            
                <li><a href="../classes/Entity.html">Entity</a></li>
            
                <li><a href="../classes/Filter.html">Filter</a></li>
            
                <li><a href="../classes/Force.html">Force</a></li>
            
                <li><a href="../classes/Gradient.html">Gradient</a></li>
            
                <li><a href="../classes/GreyscaleFilter.html">GreyscaleFilter</a></li>
            
                <li><a href="../classes/Group.html">Group</a></li>
            
                <li><a href="../classes/Image.html">Image</a></li>
            
                <li><a href="../classes/InvertFilter.html">InvertFilter</a></li>
            
                <li><a href="../classes/LeachFilter.html">LeachFilter</a></li>
            
                <li><a href="../classes/Link.html">Link</a></li>
            
                <li><a href="../classes/MatrixFilter.html">MatrixFilter</a></li>
            
                <li><a href="../classes/NoiseFilter.html">NoiseFilter</a></li>
            
                <li><a href="../classes/Pad.html">Pad</a></li>
            
                <li><a href="../classes/PageElement.html">PageElement</a></li>
            
                <li><a href="../classes/Particle.html">Particle</a></li>
            
                <li><a href="../classes/Path.html">Path</a></li>
            
                <li><a href="../classes/Pattern.html">Pattern</a></li>
            
                <li><a href="../classes/Phrase.html">Phrase</a></li>
            
                <li><a href="../classes/Picture.html">Picture</a></li>
            
                <li><a href="../classes/PixelateFilter.html">PixelateFilter</a></li>
            
                <li><a href="../classes/Point.html">Point</a></li>
            
                <li><a href="../classes/Position.html">Position</a></li>
            
                <li><a href="../classes/Quaternion.html">Quaternion</a></li>
            
                <li><a href="../classes/RadialGradient.html">RadialGradient</a></li>
            
                <li><a href="../classes/SaturationFilter.html">SaturationFilter</a></li>
            
                <li><a href="../classes/SeparateFilter.html">SeparateFilter</a></li>
            
                <li><a href="../classes/Shape.html">Shape</a></li>
            
                <li><a href="../classes/Spring.html">Spring</a></li>
            
                <li><a href="../classes/SpriteAnimation.html">SpriteAnimation</a></li>
            
                <li><a href="../classes/Stack.html">Stack</a></li>
            
                <li><a href="../classes/Text.html">Text</a></li>
            
                <li><a href="../classes/ThresholdFilter.html">ThresholdFilter</a></li>
            
                <li><a href="../classes/Timeline.html">Timeline</a></li>
            
                <li><a href="../classes/TintFilter.html">TintFilter</a></li>
            
                <li><a href="../classes/Tween.html">Tween</a></li>
            
                <li><a href="../classes/Vector.html">Vector</a></li>
            
                <li><a href="../classes/Video.html">Video</a></li>
            
                <li><a href="../classes/Wheel.html">Wheel</a></li>
            
                <li><a href="../classes/window.scrawl.html">window.scrawl</a></li>
            
                <li><a href="../classes/window.scrawl_Animation.html">window.scrawl_Animation</a></li>
            
                <li><a href="../classes/window.scrawl_Block.html">window.scrawl_Block</a></li>
            
                <li><a href="../classes/window.scrawl_Collisions.html">window.scrawl_Collisions</a></li>
            
                <li><a href="../classes/window.scrawl_Color.html">window.scrawl_Color</a></li>
            
                <li><a href="../classes/window.scrawl_Factories.html">window.scrawl_Factories</a></li>
            
                <li><a href="../classes/window.scrawl_Filters.html">window.scrawl_Filters</a></li>
            
                <li><a href="../classes/window.scrawl_Images.html">window.scrawl_Images</a></li>
            
                <li><a href="../classes/window.scrawl_Path.html">window.scrawl_Path</a></li>
            
                <li><a href="../classes/window.scrawl_Phrase.html">window.scrawl_Phrase</a></li>
            
                <li><a href="../classes/window.scrawl_Physics.html">window.scrawl_Physics</a></li>
            
                <li><a href="../classes/window.scrawl_SaveLoad.html">window.scrawl_SaveLoad</a></li>
            
                <li><a href="../classes/window.scrawl_Shape.html">window.scrawl_Shape</a></li>
            
                <li><a href="../classes/window.scrawl_Stacks.html">window.scrawl_Stacks</a></li>
            
                <li><a href="../classes/window.scrawl_Wheel.html">window.scrawl_Wheel</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/scrawlAnimation.html">scrawlAnimation</a></li>
            
                <li><a href="../modules/scrawlBlock.html">scrawlBlock</a></li>
            
                <li><a href="../modules/scrawlCollisions.html">scrawlCollisions</a></li>
            
                <li><a href="../modules/scrawlColor.html">scrawlColor</a></li>
            
                <li><a href="../modules/scrawlCore.html">scrawlCore</a></li>
            
                <li><a href="../modules/scrawlFilters.html">scrawlFilters</a></li>
            
                <li><a href="../modules/scrawlImages.html">scrawlImages</a></li>
            
                <li><a href="../modules/scrawlPath.html">scrawlPath</a></li>
            
                <li><a href="../modules/scrawlPathFactories.html">scrawlPathFactories</a></li>
            
                <li><a href="../modules/scrawlPhrase.html">scrawlPhrase</a></li>
            
                <li><a href="../modules/scrawlPhysics.html">scrawlPhysics</a></li>
            
                <li><a href="../modules/scrawlSaveLoad.html">scrawlSaveLoad</a></li>
            
                <li><a href="../modules/scrawlShape.html">scrawlShape</a></li>
            
                <li><a href="../modules/scrawlStacks.html">scrawlStacks</a></li>
            
                <li><a href="../modules/scrawlWheel.html">scrawlWheel</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: source\scrawlImages.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
//---------------------------------------------------------------------------------
// The MIT License (MIT)
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//---------------------------------------------------------------------------------


/**
# scrawlImages

## Purpose and features

The Images module adds support for displaying images on canvas elements

* Defines the EntityImage object, which wraps &amp;lt;img&amp;gt; and &amp;lt;svg&amp;gt; elements
* Adds functionality to load images into the Scrawl library dynamically (after the web page hads loaded)
* Defines the Picture entity, which can be used to display file images (including animated entity sheets), other &amp;lt;canvas&amp;gt; elements, and &amp;lt;video&amp;gt; elements (experimental)
* Defines the AnimSheet object, which in turn define and control action sequences from entity sheet images
* Defines the Pattern design, which uses images for entity fillStyle and strokeStyle attributes

@module scrawlImages
**/

if (window.scrawl &amp;&amp; window.scrawl.modules &amp;&amp; !window.scrawl.contains(window.scrawl.modules, &#x27;images&#x27;)) {
	var scrawl = (function(my) {
		&#x27;use strict&#x27;;

		/**
# window.scrawl

scrawlImages module adaptions to the Scrawl library object

## New library sections

* scrawl.image - for ScrawlImage objects
* scrawl.img - linking to copies of DOM &amp;lt;img&amp;gt; elements - links to the original elements are stored in scrawl.object
* scrawl.anim - for AnimSheet objects

@class window.scrawl_Images
**/

		/**
Alias for makePattern()
@method newPattern
@deprecated
**/
		my.newPattern = function(items) {
			return my.makePattern(items);
		};
		/**
Alias for makePicture()
@method newPicture
@deprecated
**/
		my.newPicture = function(items) {
			return my.makePicture(items);
		};
		/**
A __factory__ function to generate new Pattern objects
@method makePattern
@param {Object} items Key:value Object argument for setting attributes
@return Pattern object
**/
		my.makePattern = function(items) {
			return new my.Pattern(items);
		};
		/**
A __factory__ function to generate new Picture entitys
@method makePicture
@param {Object} items Key:value Object argument for setting attributes
@return Picture entity object
**/
		my.makePicture = function(items) {
			return new my.Picture(items);
		};

		/**
A __factory__ function to convert a entity into a Picture entity

Argument attributes can include any entity positioning and styling values, alongside the following flag:

* __convert__ - when set to true, existing entity will be deleted; default: false

If no name attribute is supplied in the argument object, the new Picture entity will be given the name: SPRITENAME+&#x27;_picture&#x27;
@method Entity.convertToPicture
@param {Object} items Key:value Object argument for setting attributes
@return Picture entity object
**/
		my.Entity.prototype.convertToPicture = function(items) {
			var image,
				cell,
				engine;
			items = my.safeObject(items);
			cell = my.cell[my.group[this.group].cell];
			engine = my.context[my.group[this.group].cell];
			image = my.prepareConvert(cell, engine, this);
			items.name = items.name || this.name + &#x27;_picture&#x27;;
			items.group = items.group || this.group;
			if (items.convert) {
				my.deleteEntity([this.name]);
			}
			return my.doConvert(image, items);
		};
		/**
A __factory__ function to convert a group of entitys into a single Picture entity

Argument attributes can include any entity positioning and styling values, alongside the following flag:

* __convert__ - when set to true, existing entitys in the group will be deleted; default: false

If no name attribute is supplied in the argument object, the new Picture entity will be given the name: GROUPNAME+&#x27;_entity&#x27;
@method Group.convertGroupToPicture
@param {Object} items Key:value Object argument for setting attributes
@return Picture entity object; false if no entitys contained in group
**/
		my.Group.prototype.convertGroupToPicture = function(items) {
			var image,
				cell,
				engine;
			items = my.safeObject(items);
			if (this.entitys.length &gt; 0) {
				cell = my.cell[this.cell];
				engine = my.context[this.cell];
				image = my.prepareConvert(cell, engine, this);
				items.name = items.name || this.name + &#x27;_entity&#x27;;
				items.group = items.group || this.name;
				if (items.convert) {
					my.deleteEntity(this.entitys);
				}
				return my.doConvert(image, items);
			}
			return false;
		};
		/**
Helper function for convert functions
@method prepareConvert
@return ImageData object
@private
**/
		my.prepareConvert = function(cell, ctx, obj) {
			var image,
				data,
				left,
				right,
				top,
				bottom,
				pos,
				i,
				iz,
				j,
				jz;
			left = cell.actualWidth;
			right = 0;
			top = cell.actualHeight;
			bottom = 0;
			cell.clear();
			obj.stamp(null, cell.name);
			image = ctx.getImageData(0, 0, cell.actualWidth, cell.actualHeight);
			data = image.data;
			for (i = 0, iz = cell.actualHeight; i &lt; iz; i++) {
				for (j = 0, jz = cell.actualWidth; j &lt; jz; j++) {
					pos = (((i * cell.actualWidth) + j) * 4) + 3;
					if (data[pos] &gt; 0) {
						top = (top &gt; i) ? i : top;
						bottom = (bottom &lt; i) ? i : bottom;
						left = (left &gt; j) ? j : left;
						right = (right &lt; j) ? j : right;
					}
				}
			}
			image = ctx.getImageData(left, top, (right - left + 1), (bottom - top + 1));
			cell.clear();
			return image;
		};
		/**
Helper function for convert functions
@method doConvert
@return Picture entity object
@private
**/
		my.doConvert = function(image, items) {
			my.imageCanvas.width = image.width;
			my.imageCanvas.height = image.height;
			my.imageCvx.putImageData(image, 0, 0);
			items.url = my.imageCanvas.toDataURL();
			items.width = image.width;
			items.height = image.height;
			image = my.makeImage(items);
			return my.makePicture(items);
		};
		/**
# Pattern

## Instantiation

* scrawl.makePattern()

## Purpose

* Defines a pattern
* Used with entity.strokeStyle and entity.fillStyle attributes

Note that a pattern image will always start at the entity&#x27;s rotation/reflection (start vector) position, extending in all directions. To move a entity over a &#x27;static&#x27; (cell-bound) pattern, more inventive solutions need to be found - for instance a combination of Picture entitys, dedicated cells and the &#x27;source-in&#x27; globalCompositeOperation attribute.

Patterns are not restricted to images. A pattern can also be sourced from another cell (canvas element) or even a video element.

## Access

* scrawl.design.PATTERNNAME - for the Pattern design object

@class Pattern
@constructor
@extends Base
@param {Object} [items] Key:value Object argument for setting attributes
**/
		my.Pattern = function(items) {
			var temp;
			if (my.isa(items, &#x27;obj&#x27;) &amp;&amp; my.xt(items.url) &amp;&amp; !my.xt(items.dynamic)) {
				items.dynamic = true;
				temp = my.makeImage(items);
				items.source = temp.name;
				return my.makePattern(items);
			}
			else {
				items = my.safeObject(items);
				my.Base.call(this, items);
				my.Base.prototype.set.call(this, items);
				this.repeat = items.repeat || &#x27;repeat&#x27;;
				this.sourceType = this.getSourceType();
				my.design[this.name] = this;
				my.pushUnique(my.designnames, this.name);
				this.makeDesign();
			}
			return this;
		};
		my.Pattern.prototype = Object.create(my.Base.prototype);
		/**
@property type
@type String
@default &#x27;Pattern&#x27;
@final
**/
		my.Pattern.prototype.type = &#x27;Pattern&#x27;;
		my.Pattern.prototype.classname = &#x27;designnames&#x27;;
		my.d.Pattern = {
			/**
Drawing parameter
@property repeat
@type String
@default &#x27;repeat&#x27;
**/
			repeat: &#x27;repeat&#x27;,
			/**
CELLNAME, VIDEONAME or IMAGENAME of Pattern source data
@property source
@type String
@default &#x27;&#x27;
**/
			source: &#x27;&#x27;,
			/**
Drawing flag - when set to true, force the pattern to update each drawing cycle - only required in the simplest scenes where fillStyle and strokeStyle do not change between entities
@property autoUpdate
@type Boolean
@default false
**/
			autoUpdate: false,
			/**
Asynchronous loading of image file from the server - path/to/image file

Used only with __scrawl.makePattern()__ and __Pattern.clone()__ operations. This attribute is not retained
@property url
@type String
@default &#x27;&#x27;
**/
			/**
Asynchronous loading of image file from the server - function to run once image has successfully loaded

Used only with __scrawl.makePattern()__ and __Pattern.clone()__ operations. This attribute is not retained
@property callback
@type Function
@default undefined
**/
			callback: false,
		};
		my.mergeInto(my.d.Pattern, my.d.Base);
		/**
Constructor/set helper
@method getSourceType
@return String - one from: &#x27;image&#x27;, &#x27;cell&#x27;, &#x27;video&#x27;; false on failure to identify source type
**/
		my.Pattern.prototype.getSourceType = function() {
			if (my.contains(my.imagenames, this.source)) {
				return &#x27;image&#x27;;
			}
			if (my.contains(my.cellnames, this.source)) {
				return &#x27;cell&#x27;;
			}
			if (my.contains(my.videonames, this.source)) {
				return &#x27;video&#x27;;
			}
			return false;
		};
		/**
Augments Base.set()
@method set
@param {Object} items Object consisting of key:value attributes
@return This
@chainable
**/
		my.Pattern.prototype.set = function(items) {
			my.Base.prototype.set.call(this, items);
			this.sourceType = this.getSourceType();
			this.makeDesign();
			return this;
		};
		/**
Returns &amp;lt;canvas&amp;gt; element&#x27;s contenxt engine&#x27;s pattern object, or &#x27;rgba(0,0,0,0)&#x27; on failure
@method getData
@return JavaScript pattern object, or String
@private
**/
		my.Pattern.prototype.getData = function(entity, cell) {
			if (!this.sourceType) {
				this.sourceType = this.getSourceType();
				this.makeDesign(entity, cell);
			}
			return (my.xt(my.dsn[this.name])) ? my.dsn[this.name] : &#x27;rgba(0,0,0,0)&#x27;;
		};
		/**
Builds &amp;lt;canvas&amp;gt; element&#x27;s contenxt engine&#x27;s pattern object
@method makeDesign
@return This
@chainable
@private
**/
		my.Pattern.prototype.makeDesign = function(entity, cell) {
			var temp,
				engine;
			cell = my.xtGet(cell, this.cell);
			engine = my.context[cell];
			if (my.xt(engine)) {
				switch (this.sourceType) {
					case &#x27;video&#x27;:
						if (scrawl.xt(my.asset[this.source])) {
							temp = my.video[this.source].api;
							if (temp.readyState &gt; 1) {
								my.dsn[this.name] = engine.createPattern(my.asset[this.source], this.repeat);
							}
							else {
								my.dsn[this.name] = undefined;
							}
						}
						break;
					case &#x27;cell&#x27;:
						if (scrawl.xt(my.canvas[this.source])) {
							my.dsn[this.name] = engine.createPattern(my.canvas[this.source], this.repeat);
						}
						break;
					case &#x27;image&#x27;:
						if (scrawl.xt(my.asset[this.source])) {
							my.dsn[this.name] = engine.createPattern(my.asset[this.source], this.repeat);
						}
						break;
				}
			}
			return this;
		};
		/**
Remove this pattern from the scrawl library
@method remove
@return Always true
**/
		my.Pattern.prototype.remove = function() {
			delete my.dsn[this.name];
			delete my.design[this.name];
			my.removeItem(my.designnames, this.name);
			return true;
		};
		/**
Alias for Pattern.makeDesign()
@method update
@return This
@chainable
**/
		my.Pattern.prototype.update = function(entity, cell) {
			return this.makeDesign(entity, cell);
		};

		/**
# Picture

## Instantiation

* scrawl.makePicture()

## Purpose

* Defines rectangular image-based objects for displaying on a Cell&#x27;s canvas
* Used to display both static and entity sheet image animations
* Links to details of an image&#x27;s data; can use image data (rgba data) during collision detection
* Can handle video input (experimental)
* Performs &#x27;rect&#x27; and &#x27;drawImage&#x27; drawing operations on canvases

## Access

* scrawl.entity.PICTURENAME - for the Picture entity object

@class Picture
@constructor
@extends Entity
@uses AnimSheet
@param {Object} [items] Key:value Object argument for setting attributes
**/
		my.Picture = function(items) {
			var temp,
				tempV,
				src;
			if (my.isa(items, &#x27;obj&#x27;) &amp;&amp; my.xt(items.url) &amp;&amp; !my.xt(items.dynamic)) {
				items.dynamic = true;
				temp = my.makeImage(items);
				items.source = temp.name;
				return my.makePicture(items);
			}
			else {
				items = my.safeObject(items);
				if (my.xt(items.source)) {
					src = my.xtGet(my.image[items.source], my.video[items.source], my.cell[items.source], false);
					if (src) {
						my.Entity.call(this, items);
						tempV = my.safeObject(items.paste);
						//start vector already set by the Entity call
						this.start.x = my.xtGet(items.pasteX, tempV.x, this.start.x);
						this.start.y = my.xtGet(items.pasteY, tempV.y, this.start.y);
						this.copyWidth = my.xtGetTrue(items.copyWidth, src.actualWidth, src.width, &#x27;100%&#x27;);
						this.copyHeight = my.xtGetTrue(items.copyHeight, src.actualHeight, src.height, &#x27;100%&#x27;);
						this.width = my.xtGet(items.pasteWidth, items.width, this.copyWidth);
						this.height = my.xtGet(items.pasteHeight, items.height, this.copyHeight);
						my.Position.prototype.set.call(this, items);
						this.source = items.source;
						this.imageType = this.sourceImage();
						tempV = my.safeObject(items.copy);
						this.copy = my.makeVector({
							x: my.xtGet(items.copyX, tempV.x, 0),
							y: my.xtGet(items.copyY, tempV.y, 0),
							name: this.type + &#x27;.&#x27; + this.name + &#x27;.copy&#x27;
						});
						this.work.copy = my.makeVector({
							name: this.type + &#x27;.&#x27; + this.name + &#x27;.work.copy&#x27;
						});
						this.registerInLibrary();
						this.copyData = {};
						this.pasteData = {};
						this.setCopy();
						this.setPaste();
						return this;
					}
				}
			}
			return false;
		};
		my.Picture.prototype = Object.create(my.Entity.prototype);
		/**
@property type
@type String
@default &#x27;Picture&#x27;
@final
**/
		my.Picture.prototype.type = &#x27;Picture&#x27;;
		my.Picture.prototype.classname = &#x27;entitynames&#x27;;
		my.d.Picture = {
			/**
SCRAWLIMAGE String - source image for this entity
@property source
@type String
@default &#x27;&#x27;
**/
			source: &#x27;&#x27;,
			/**
IMAGEDATANAME String - name of the Image Data object

Calculated automatically by Scrawl following a .getImageData() call
@property imageData
@type String
@default &#x27;&#x27;
**/
			imageData: &#x27;&#x27;,
			/**
Collision attribute - name of channel to be checked against during collision detection

Permitted values: &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;alpha&#x27;
@property imageDataChannel
@type String
@default &#x27;alpha&#x27;
**/
			imageDataChannel: &#x27;alpha&#x27;,
			/**
SPRITEANIMATIONNAME String - Entity sheet image linked to this entity
@property animSheet
@type String
@default ;;
**/
			animation: &#x27;&#x27;,
			/**
Identifier String - permitted values include: &#x27;animation&#x27;, &#x27;canvas&#x27;, &#x27;img&#x27;

Detected automatically by scrawl during entity construction
@property imageType
@type String
@default &#x27;&#x27;
@private
**/
			imageType: &#x27;&#x27;,
			/**
Collision flag - when true, Picture entity will use imageData to determine whether a collision has occured; when false, a simpler box collision system is used
@property checkHitUsingImageData
@type Boolean
@default false
**/
			checkHitUsingImageData: false,
			/**
The coordinate Vector representing the Picture&#x27;s copy source position on its source;

Picture supports the following &#x27;virtual&#x27; attributes for this attribute:

* __copyX__ - (Number) the x coordinate on the source
* __copyY__ - (Number) the y coordinate on the sourcecopy

@property copy
@type Vector
**/
			copy: false,
			/**
Copy width, in pixels. Determines which portion of this Picture&#x27;s source will be copied
@property copyWidth
@type Number
@default 300
**/
			copyWidth: 300,
			/**
Copy height, in pixels. Determines which portion of this Picture&#x27;s source will be copied
@property copyHeight
@type Number
@default 150
**/
			copyHeight: 150,
			/**
Local source data
@property copyData
@type Object
@default false
@private
**/
			copyData: false,
			/**
Local target data
@property pasteData
@type Object
@default false
@private
**/
			pasteData: false,
			/**
Asynchronous loading of image file from the server - path/to/image file

Used only with __scrawl.makePicture()__ and __Picture.clone()__ operations. This attribute is not retained
@property url
@type String
@default &#x27;&#x27;
**/
			/**
Asynchronous loading of image file from the server - function to run once image has successfully loaded

Used only with __scrawl.makePicture()__ and __Picture.clone()__ operations. This attribute is not retained
@property callback
@type Function
@default undefined
**/
			callback: false,
		};
		my.mergeInto(my.d.Picture, my.d.Entity);
		/**
Augments Entity.get()
@method get
@param {String} item Attribute to be retrieved
@return Attribute value
**/
		my.Picture.prototype.get = function(item) {
			if (my.contains(my.animKeys, item)) {
				return my.spriteanimation[this.animation].get(item);
			}
			else {
				return my.Entity.prototype.get.call(this, item);
			}
		};
		/**
Augments Entity.set()
@method set
@param {Object} items Object consisting of key:value attributes
@return This
@chainable
**/
		my.Picture.prototype.set = function(items) {
			var temp;
			my.Entity.prototype.set.call(this, items);
			if (my.xto(items.paste, items.pasteX, items.pasteY)) {
				temp = my.safeObject(items.paste);
				this.start.x = my.xtGet(items.pasteX, temp.x, this.start.x);
				this.start.y = my.xtGet(items.pasteY, temp.y, this.start.y);
			}
			if (my.xt(items.pasteWidth)) {
				this.width = my.xtGet(items.pasteWidth, this.width);
			}
			if (my.xt(items.pasteHeight)) {
				this.height = my.xtGet(items.pasteHeight, this.height);
			}
			if (my.xto(items.copy, items.copyX, items.copyY)) {
				temp = my.safeObject(items.copy);
				this.copy.x = my.xtGet(items.copyX, temp.x, this.copy.x);
				this.copy.y = my.xtGet(items.copyY, temp.y, this.copy.y);
			}
			if (my.xt(items.copyWidth)) {
				this.copyWidth = my.xtGet(items.copyWidth, this.copyWidth);
			}
			if (my.xt(items.copyHeight)) {
				this.copyHeight = my.xtGet(items.copyHeight, this.copyHeight);
			}
			if (my.xto(items.start, items.startX, items.startY, items.paste, items.pasteX, items.pasteY, items.pasteWidth, items.pasteHeight, items.width, items.height, items.scale)) {
				this.setPaste();
			}
			if (my.xto(items.copy, items.copyX, items.copyY, items.copyWidth, items.copyHeight, items.width, items.height)) {
				this.setCopy();
			}
			if (my.xt(this.animation)) {
				my.spriteanimation[this.animation].set(items);
			}
			return this;
		};
		/**
Augments Entity.setDelta()
@method setDelta
@param {Object} items Object consisting of key:value attributes
@return This
@chainable
**/
		my.Picture.prototype.setDelta = function(items) {
			var temp,
				x,
				y,
				w,
				h;
			my.Entity.prototype.setDelta.call(this, items);
			items = my.safeObject(items);
			if (my.xto(items.paste, items.pasteX, items.pasteY)) {
				temp = my.safeObject(items.paste);
				x = my.xtGet(items.pasteX, temp.x, 0);
				y = my.xtGet(items.pasteY, temp.y, 0);
				this.start.x = (my.isa(this.start.x, &#x27;num&#x27;)) ? this.start.x + x : my.addPercentages(this.start.x, x);
				this.start.y = (my.isa(this.start.y, &#x27;num&#x27;)) ? this.start.y + y : my.addPercentages(this.start.y, y);
			}
			if (my.xto(items.pasteWidth, items.width)) {
				w = my.xtGet(items.pasteWidth, items.width);
				this.width = (my.isa(this.width, &#x27;num&#x27;)) ? this.width + w : my.addPercentages(this.width, w);
			}
			if (my.xto(items.pasteHeight, items.height)) {
				h = my.xtGet(items.pasteHeight, items.height);
				this.height = (my.isa(this.height, &#x27;num&#x27;)) ? this.height + h : my.addPercentages(this.height, h);
			}
			if (my.xto(items.copy, items.copyX, items.copyY)) {
				temp = my.safeObject(items.copy);
				x = my.xtGet(items.copyX, temp.x, 0);
				y = my.xtGet(items.copyY, temp.y, 0);
				this.copy.x = (my.isa(this.copy.x, &#x27;num&#x27;)) ? this.copy.x + x : my.addPercentages(this.copy.x, x);
				this.copy.y = (my.isa(this.copy.y, &#x27;num&#x27;)) ? this.copy.y + y : my.addPercentages(this.copy.y, y);
			}
			if (my.xto(items.copyWidth, items.width)) {
				w = my.xtGet(items.copyWidth, items.width);
				this.copyWidth = (my.isa(this.copyWidth, &#x27;num&#x27;)) ? this.copyWidth + w : my.addPercentages(this.copyWidth, w);
			}
			if (my.xto(items.copyHeight, items.height)) {
				h = my.xtGet(items.copyHeight, items.height);
				this.copyHeight = (my.isa(this.copyHeight, &#x27;num&#x27;)) ? this.copyHeight + h : my.addPercentages(this.copyHeight, h);
			}
			if (my.xto(items.start, items.startX, items.startY, items.paste, items.pasteX, items.pasteY, items.pasteWidth, items.pasteHeight, items.width, items.height, items.scale)) {
				this.setPaste();
			}
			if (my.xto(items.copy, items.copyX, items.copyY, items.copyWidth, items.copyHeight, items.width, items.height)) {
				this.setCopy();
			}
			return this;
		};
		/**
Picture.setCopy update copyData object values
@method setSource
@chainable
@private
**/
		my.Picture.prototype.setCopy = function() {
			var w,
				h;
			switch (this.imageType) {
				case &#x27;canvas&#x27;:
					w = my.cell[this.source].actualWidth;
					h = my.cell[this.source].actualHeight;
					break;
				case &#x27;video&#x27;:
					w = my.video[this.source].width;
					h = my.video[this.source].height;
					break;
				case &#x27;img&#x27;:
					w = my.image[this.source].width;
					h = my.image[this.source].height;
					break;
				default:
					//do nothing for animations
			}
			if (this.imageType !== &#x27;animation&#x27;) {
				this.copyData.x = (my.isa(this.copy.x, &#x27;str&#x27;)) ? this.convertX(this.copy.x, w) : this.copy.x;
				this.copyData.y = (my.isa(this.copy.y, &#x27;str&#x27;)) ? this.convertY(this.copy.y, h) : this.copy.y;
				if (!my.isBetween(this.copyData.x, 0, w - 1, true)) {
					this.copyData.x = (this.copyData.x &lt; 0) ? 0 : w - 1;
				}
				if (!my.isBetween(this.copyData.y, 0, h - 1, true)) {
					this.copyData.y = (this.copyData.y &lt; 0) ? 0 : h - 1;
				}
				this.copyData.w = (my.isa(this.copyWidth, &#x27;str&#x27;)) ? this.convertX(this.copyWidth, w) : this.copyWidth;
				this.copyData.h = (my.isa(this.copyHeight, &#x27;str&#x27;)) ? this.convertY(this.copyHeight, h) : this.copyHeight;
				if (!my.isBetween(this.copyData.w, 1, w, true)) {
					this.copyData.w = (this.copyData.w &lt; 1) ? 1 : w;
				}
				if (!my.isBetween(this.copyData.h, 1, h, true)) {
					this.copyData.h = (this.copyData.h &lt; 1) ? 1 : h;
				}
				if (this.copyData.x + this.copyData.w &gt; w) {
					this.copyData.x = w - this.copyData.w;
				}
				if (this.copyData.y + this.copyData.h &gt; h) {
					this.copyData.y = h - this.copyData.h;
				}
			}
			this.imageData = false;
			return this;
		};
		/**
Picture.setPaste update pasteData object values
@method setPaste
@chainable
@private
**/
		my.Picture.prototype.setPaste = function() {
			var cell = my.cell[my.group[this.group].cell];
			this.pasteData.x = (my.isa(this.start.x, &#x27;str&#x27;)) ? this.convertX(this.start.x, cell.actualWidth) : this.start.x;
			this.pasteData.y = (my.isa(this.start.y, &#x27;str&#x27;)) ? this.convertY(this.start.y, cell.actualHeight) : this.start.y;
			this.pasteData.w = (my.isa(this.width, &#x27;str&#x27;)) ? this.convertX(this.width, cell.actualWidth) : this.width;
			this.pasteData.h = (my.isa(this.height, &#x27;str&#x27;)) ? this.convertY(this.height, cell.actualHeight) : this.height;
			this.pasteData.w *= this.scale;
			this.pasteData.h *= this.scale;
			if (this.pasteData.w &lt; 1) {
				this.pasteData.w = 1;
			}
			if (this.pasteData.h &lt; 1) {
				this.pasteData.h = 1;
			}
			return this;
		};
		/**
Augments Entity.clone()
@method clone
@param {Object} items Object consisting of key:value attributes, used to update the clone&#x27;s attributes with new values
@return Cloned object
@chainable
**/
		my.Picture.prototype.clone = function(items) {
			var a = my.Entity.prototype.clone.call(this, items);
			items = my.safeObject(items);
			if (!items.keepCopyDimensions) {
				a.fitToImageSize();
			}
			return a;
		};
		/**
Clone helper function
@method fitToImageSize
@return This
@chainable
@private
**/
		my.Picture.prototype.fitToImageSize = function() {
			var img;
			if (this.imageType === &#x27;img&#x27;) {
				img = my.image[this.source];
				this.set({
					copyWidth: img.get(&#x27;width&#x27;),
					copyHeight: img.get(&#x27;height&#x27;),
					copyX: 0,
					copyY: 0,
				});
			}
			return this;
		};
		/**
Constructor and clone helper function
@method sourceImage
@return Correct imageType attribute value for this entity
@private
**/
		my.Picture.prototype.sourceImage = function() {
			if (my.contains(my.videonames, this.source)) {
				return &#x27;video&#x27;;
			}
			if (my.contains(my.imagenames, this.source)) {
				if (my.contains(my.spriteanimationnames, this.animation)) {
					return &#x27;animation&#x27;;
				}
				return &#x27;img&#x27;;
			}
			if (my.contains(my.cellnames, this.source)) {
				return &#x27;canvas&#x27;;
			}

			return false;
		};
		/**
Stamp helper function - perform a &#x27;clip&#x27; method draw
@method clip
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Picture.prototype.clip = function(ctx, cell) {
			var here = this.prepareStamp();
			this.rotateCell(ctx, cell);
			ctx.beginPath();
			ctx.rect(here.x, here.y, this.pasteData.w, this.pasteData.h);
			ctx.clip();
			return this;
		};
		/**
Stamp helper function - perform a &#x27;none&#x27; method draw
@method none
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Picture.prototype.none = function(ctx, cell) {
			this.prepareStamp();
			return this;
		};
		/**
Stamp helper function - perform a &#x27;clear&#x27; method draw
@method clear
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Picture.prototype.clear = function(ctx, cell) {
			var here = this.prepareStamp();
			this.rotateCell(ctx, cell);
			ctx.clearRect(here.x, here.y, this.pasteData.w, this.pasteData.h);
			return this;
		};
		/**
Stamp helper function - perform a &#x27;clearWithBackground&#x27; method draw
@method clearWithBackground
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Picture.prototype.clearWithBackground = function(ctx, cell) {
			var here = this.prepareStamp();
			this.rotateCell(ctx, cell);
			ctx.fillStyle = my.cell[cell].backgroundColor;
			ctx.strokeStyle = my.cell[cell].backgroundColor;
			ctx.globalAlpha = 1;
			ctx.strokeRect(here.x, here.y, this.pasteData.w, this.pasteData.h);
			ctx.fillRect(here.x, here.y, this.pasteData.w, this.pasteData.h);
			ctx.fillStyle = my.ctx[cell].fillStyle;
			ctx.strokeStyle = my.ctx[cell].strokeStyle;
			ctx.globalAlpha = my.ctx[cell].globalAlpha;
			return this;
		};
		/**
Stamp helper function - perform a &#x27;draw&#x27; method draw
@method draw
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Picture.prototype.draw = function(ctx, cell) {
			var here = this.prepareStamp();
			this.rotateCell(ctx, cell);
			my.cell[cell].setEngine(this);
			ctx.strokeRect(here.x, here.y, this.pasteData.w, this.pasteData.h);
			return this;
		};
		/**
Stamp helper function - perform a &#x27;fill&#x27; method draw
@method fill
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Picture.prototype.fill = function(ctx, cell) {
			var here,
				data = this.getImage();
			if (data) {
				here = this.prepareStamp();
				this.rotateCell(ctx, cell);
				my.cell[cell].setEngine(this);
				ctx.drawImage(data, this.copyData.x, this.copyData.y, this.copyData.w, this.copyData.h, here.x, here.y, this.pasteData.w, this.pasteData.h);
			}
			return this;
		};
		/**
Stamp helper function - perform a &#x27;drawFill&#x27; method draw
@method drawFill
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Picture.prototype.drawFill = function(ctx, cell) {
			var here,
				data = this.getImage();
			if (data) {
				here = this.prepareStamp();
				this.rotateCell(ctx, cell);
				my.cell[cell].setEngine(this);
				ctx.strokeRect(here.x, here.y, this.pasteData.w, this.pasteData.h);
				this.clearShadow(ctx, cell);
				ctx.drawImage(data, this.copyData.x, this.copyData.y, this.copyData.w, this.copyData.h, here.x, here.y, this.pasteData.w, this.pasteData.h);
			}
			return this;
		};
		/**
Stamp helper function - perform a &#x27;fillDraw&#x27; method draw
@method fillDraw
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Picture.prototype.fillDraw = function(ctx, cell) {
			var here,
				data = this.getImage();
			if (data) {
				here = this.prepareStamp();
				this.rotateCell(ctx, cell);
				my.cell[cell].setEngine(this);
				ctx.drawImage(data, this.copyData.x, this.copyData.y, this.copyData.w, this.copyData.h, here.x, here.y, this.pasteData.w, this.pasteData.h);
				this.clearShadow(ctx, cell);
				ctx.strokeRect(here.x, here.y, this.pasteData.w, this.pasteData.h);
			}
			return this;
		};
		/**
Stamp helper function - perform a &#x27;sinkInto&#x27; method draw
@method sinkInto
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Picture.prototype.sinkInto = function(ctx, cell) {
			var here,
				data = this.getImage();
			if (data) {
				here = this.prepareStamp();
				this.rotateCell(ctx, cell);
				my.cell[cell].setEngine(this);
				ctx.drawImage(data, this.copyData.x, this.copyData.y, this.copyData.w, this.copyData.h, here.x, here.y, this.pasteData.w, this.pasteData.h);
				ctx.strokeRect(here.x, here.y, this.pasteData.w, this.pasteData.h);
			}
			return this;
		};
		/**
Stamp helper function - perform a &#x27;floatOver&#x27; method draw
@method floatOver
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Picture.prototype.floatOver = function(ctx, cell) {
			var here,
				data = this.getImage();
			if (data) {
				here = this.prepareStamp();
				this.rotateCell(ctx, cell);
				my.cell[cell].setEngine(this);
				ctx.strokeRect(here.x, here.y, this.pasteData.w, this.pasteData.h);
				ctx.drawImage(data, this.copyData.x, this.copyData.y, this.copyData.w, this.copyData.h, here.x, here.y, this.pasteData.w, this.pasteData.h);
			}
			return this;
		};

		/**
Display helper function - retrieve copy attributes for ScrawlImage, taking into account the current frame for entity sheet images

Also generates new filtered images, when necessary
@method getImage
@return Image Object
@private
**/
		my.Picture.prototype.getImage = function() {
			var anim;
			switch (this.imageType) {
				case &#x27;img&#x27;:
					return my.asset[this.source];
				case &#x27;animation&#x27;:
					anim = my.spriteanimation[this.animation].getData();
					this.copyData.x = anim.x;
					this.copyData.y = anim.y;
					this.copyData.w = anim.w;
					this.copyData.h = anim.h;
					return my.asset[this.source];
				case &#x27;canvas&#x27;:
					return my.canvas[this.source];
				case &#x27;video&#x27;:
					return my.asset[this.source];
				default:
					return false;
			}
		};
		/**
Load the Picture entity&#x27;s image data (via JavaScript getImageData() function) into the scrawl library
@method getImageData
@param {String} [label] IMAGEDATANAME - default: PICTURENAME_data
@return This
@chainable
**/
		my.Picture.prototype.getImageData = function(label) {
			var data;
			label = (my.xt(label)) ? label : &#x27;data&#x27;;
			data = this.getImage();
			if (data) {
				my.imageCanvas.width = this.copyData.w;
				my.imageCanvas.height = this.copyData.h;
				my.imageCvx.drawImage(data, this.copyData.x, this.copyData.y, this.copyData.w, this.copyData.h, 0, 0, this.copyData.w, this.copyData.h);
				this.imageData = this.name + &#x27;_&#x27; + label;
				my.imageData[this.imageData] = my.imageCvx.getImageData(0, 0, this.copyData.w, this.copyData.h);
			}
			return this;
		};
		/**
Get the pixel color or channel data from Picture object&#x27;s image at given coordinate

Argument needs to have __x__ and __y__ data (pixel coordinates) and, optionally, a __channel__ string - &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;alpha&#x27; (default), &#x27;color&#x27;
@method getImageDataValue
@param {Object} items Coordinate Vector or Object
@return Color value at coordinate; false if no color found
**/
		my.Picture.prototype.getImageDataValue = function(items) {
			var data,
				array,
				index;
			items = my.safeObject(items);
			my.workimg.v1.x = items.x || 0;
			my.workimg.v1.y = items.y || 0;
			my.workimg.v1.vectorSubtract(this.pasteData).rotate(-this.roll);
			my.workimg.v1.x = (this.flipReverse) ? -my.workimg.v1.x : my.workimg.v1.x;
			my.workimg.v1.y = (this.flipUpend) ? -my.workimg.v1.y : my.workimg.v1.y;
			my.workimg.v1.vectorSubtract(this.getPivotOffsetVector(this.handle));
			my.workimg.v1.x = Math.round(my.workimg.v1.x * (this.copyData.w / this.pasteData.w));
			my.workimg.v1.y = Math.round(my.workimg.v1.y * (this.copyData.h / this.pasteData.h));
			if (!this.imageData) {
				this.getImageData();
			}
			data = my.imageData[this.imageData];
			index = ((my.workimg.v1.y * data.width) + my.workimg.v1.x) * 4;
			if (my.isBetween(my.workimg.v1.x, 0, data.width - 1, true) &amp;&amp; my.isBetween(my.workimg.v1.y, 0, data.height - 1, true)) {
				array = data.data;
				switch (items.channel || this.get(&#x27;imageDataChannel&#x27;)) {
					case &#x27;red&#x27;:
						return (my.xt(array[index])) ? array[index] : false;
					case &#x27;green&#x27;:
						return (my.xt(array[index + 1])) ? array[index + 1] : false;
					case &#x27;blue&#x27;:
						return (my.xt(array[index + 2])) ? array[index + 2] : false;
					case &#x27;color&#x27;:
						return (my.xta([array[index], array[index + 1], array[index + 2], array[index + 3]])) ? &#x27;rgba(&#x27; + array[index] + &#x27;,&#x27; + array[index + 1] + &#x27;,&#x27; + array[index + 2] + &#x27;,&#x27; + array[index + 3] + &#x27;)&#x27; : false;
					default: // alpha
						return (my.xt(array[index + 3])) ? array[index + 3] : false;
				}
			}
			return false;
		};
		/**
Check Cell coordinates to see if any of them fall within this entity&#x27;s path - uses JavaScript&#x27;s _isPointInPath_ function

Argument object contains the following attributes:

* __tests__ - an array of Vector coordinates to be checked; alternatively can be a single Vector
* __x__ - X coordinate
* __y__ - Y coordinate

Either the &#x27;tests&#x27; attribute should contain a Vector, or an array of vectors, or the x and y attributes should be set to Number values
@method checkHit
@param {Object} items Argument object
@return The first coordinate to fall within the entity&#x27;s path; false if none fall within the path
**/
		my.Picture.prototype.checkHit = function(items) {
			var tests = [],
				hit = [],
				testBar,
				colorResult,
				result,
				i,
				iz,
				arg = {
					tests: []
				};
			items = my.safeObject(items);
			if (my.xt(items.tests)) {
				tests = items.tests;
			}
			else {
				tests.length = 0;
				tests.push(items.x || 0);
				tests.push(items.y || 0);
			}
			testBar = (my.isa(items.test, &#x27;num&#x27;)) ? items.test : 0;
			for (i = 0, iz = tests.length; i &lt; iz; i += 2) {
				result = null;
				arg.tests.length = 0;
				arg.tests.push(tests[i]);
				arg.tests.push(tests[i + 1]);
				hit = my.Entity.prototype.checkHit.call(this, arg);
				if (this.checkHitUsingImageData) {
					if (hit) {
						hit.x = Math.floor(hit.x);
						hit.y = Math.floor(hit.y);
						if (this.animation) {
							this.imageData = false;
						}
						colorResult = this.getImageDataValue(hit);
						if (this.get(&#x27;imageDataChannel&#x27;) === &#x27;color&#x27;) {
							result = (colorResult === &#x27;rgba(0,0,0,0)&#x27;) ? false : hit;
						}
						else {
							result = (colorResult &gt; testBar) ? hit : false;
						}
					}
				}
				else {
					result = hit;
				}
				if (result) {
					break;
				}
			}
			return (result) ? result : false;
		};
		/**
Revert pickupEntity() actions, ensuring entity is left where the user drops it
@method dropEntity
@param {String} [items] Alternative pivot String
@return This
@chainable
**/
		my.Picture.prototype.dropEntity = function(item) {
			my.Entity.prototype.dropEntity.call(this, item);
			this.setPaste();
			return this;
		};


		return my;
	}(scrawl));
}

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
