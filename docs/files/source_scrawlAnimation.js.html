<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>source\scrawlAnimation.js - scrawl-canvas</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="scrawl-canvas"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 3.1.5</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Animation.html">Animation</a></li>
            
                <li><a href="../classes/AnimSheet.html">AnimSheet</a></li>
            
                <li><a href="../classes/Base.html">Base</a></li>
            
                <li><a href="../classes/Block.html">Block</a></li>
            
                <li><a href="../classes/Cell.html">Cell</a></li>
            
                <li><a href="../classes/Color.html">Color</a></li>
            
                <li><a href="../classes/Context.html">Context</a></li>
            
                <li><a href="../classes/Design.html">Design</a></li>
            
                <li><a href="../classes/Element.html">Element</a></li>
            
                <li><a href="../classes/Force.html">Force</a></li>
            
                <li><a href="../classes/Gradient.html">Gradient</a></li>
            
                <li><a href="../classes/Group.html">Group</a></li>
            
                <li><a href="../classes/Link.html">Link</a></li>
            
                <li><a href="../classes/Pad.html">Pad</a></li>
            
                <li><a href="../classes/PageElement.html">PageElement</a></li>
            
                <li><a href="../classes/Particle.html">Particle</a></li>
            
                <li><a href="../classes/Path.html">Path</a></li>
            
                <li><a href="../classes/Pattern.html">Pattern</a></li>
            
                <li><a href="../classes/Phrase.html">Phrase</a></li>
            
                <li><a href="../classes/Picture.html">Picture</a></li>
            
                <li><a href="../classes/Point.html">Point</a></li>
            
                <li><a href="../classes/Position.html">Position</a></li>
            
                <li><a href="../classes/Quaternion.html">Quaternion</a></li>
            
                <li><a href="../classes/RadialGradient.html">RadialGradient</a></li>
            
                <li><a href="../classes/ScrawlImage.html">ScrawlImage</a></li>
            
                <li><a href="../classes/Shape.html">Shape</a></li>
            
                <li><a href="../classes/Spring.html">Spring</a></li>
            
                <li><a href="../classes/Sprite.html">Sprite</a></li>
            
                <li><a href="../classes/Stack.html">Stack</a></li>
            
                <li><a href="../classes/Text.html">Text</a></li>
            
                <li><a href="../classes/Tween.html">Tween</a></li>
            
                <li><a href="../classes/Vector.html">Vector</a></li>
            
                <li><a href="../classes/Wheel.html">Wheel</a></li>
            
                <li><a href="../classes/window.scrawl.html">window.scrawl</a></li>
            
                <li><a href="../classes/window.scrawl_Animation.html">window.scrawl_Animation</a></li>
            
                <li><a href="../classes/window.scrawl_Block.html">window.scrawl_Block</a></li>
            
                <li><a href="../classes/window.scrawl_Collisions.html">window.scrawl_Collisions</a></li>
            
                <li><a href="../classes/window.scrawl_Color.html">window.scrawl_Color</a></li>
            
                <li><a href="../classes/window.scrawl_Factories.html">window.scrawl_Factories</a></li>
            
                <li><a href="../classes/window.scrawl_Filters.html">window.scrawl_Filters</a></li>
            
                <li><a href="../classes/window.scrawl_Images.html">window.scrawl_Images</a></li>
            
                <li><a href="../classes/window.scrawl_Path.html">window.scrawl_Path</a></li>
            
                <li><a href="../classes/window.scrawl_Phrase.html">window.scrawl_Phrase</a></li>
            
                <li><a href="../classes/window.scrawl_Physics.html">window.scrawl_Physics</a></li>
            
                <li><a href="../classes/window.scrawl_SaveLoad.html">window.scrawl_SaveLoad</a></li>
            
                <li><a href="../classes/window.scrawl_Shape.html">window.scrawl_Shape</a></li>
            
                <li><a href="../classes/window.scrawl_Stacks.html">window.scrawl_Stacks</a></li>
            
                <li><a href="../classes/window.scrawl_Wheel.html">window.scrawl_Wheel</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/scrawlAnimation.html">scrawlAnimation</a></li>
            
                <li><a href="../modules/scrawlBlock.html">scrawlBlock</a></li>
            
                <li><a href="../modules/scrawlCollisions.html">scrawlCollisions</a></li>
            
                <li><a href="../modules/scrawlColor.html">scrawlColor</a></li>
            
                <li><a href="../modules/scrawlCore.html">scrawlCore</a></li>
            
                <li><a href="../modules/scrawlFilters.html">scrawlFilters</a></li>
            
                <li><a href="../modules/scrawlImages.html">scrawlImages</a></li>
            
                <li><a href="../modules/scrawlPath.html">scrawlPath</a></li>
            
                <li><a href="../modules/scrawlPathFactories.html">scrawlPathFactories</a></li>
            
                <li><a href="../modules/scrawlPhrase.html">scrawlPhrase</a></li>
            
                <li><a href="../modules/scrawlPhysics.html">scrawlPhysics</a></li>
            
                <li><a href="../modules/scrawlSaveLoad.html">scrawlSaveLoad</a></li>
            
                <li><a href="../modules/scrawlShape.html">scrawlShape</a></li>
            
                <li><a href="../modules/scrawlStacks.html">scrawlStacks</a></li>
            
                <li><a href="../modules/scrawlWheel.html">scrawlWheel</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: source\scrawlAnimation.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
//---------------------------------------------------------------------------------
// The MIT License (MIT)
//
// Copyright (c) 2014 Richard James Roots
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//---------------------------------------------------------------------------------

window.requestAnimFrame = (function(callback) {
	return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
		window.setTimeout(callback, 1000 / 60);
	};
})();

/**
# scrawlAnimation

## Purpose and features

The Animation module adds support for animation and tweening to the core

* Adds and starts an animation loop to the core
* Defines the Animation object, used to program animation sequences
* Defines the Tween object - a specialized form of animation which has pre-determined start and end points, durations and easing options
* Adds functionality to various core objects and functions so they can take advantage of the animation object

@module scrawlAnimation
**/

var scrawl = (function(my) {
	&#x27;use strict&#x27;;

	/**
# window.scrawl

scrawlAnimation module adaptions to the Scrawl library object

## New library sections

* scrawl.animation - for Animation and Tween objects

* scrawl.doAnimation - a boolean switch to start/stop the animation loop
* scrawl.animate - the animation loop function

## New default attributes

* Position.delta - default: {x:0,y:0,z:0};
* Position.deltaPathPlace - default: 0;
* Position.pathSpeedConstant - default: true;
* Position.path - default: &#x27;&#x27;;

* Cell.sourceDelta - default: {x:0, y:0, z:0};
* Cell.sourceMinWidth - default: 0;
* Cell.sourceMaxWidth - default: 0;
* Cell.sourceMinHeight - default: 0;
* Cell.sourceMaxHeight - default: 0;

* Design.roll - default: 0;
* Design.autoUpdate - default: false;

@class window.scrawl_Animation
**/

	/**
Starts the animation loop
@method animationInit
@private
**/
	my.animationInit = function() {
		my.doAnimation = true;
		my.animationLoop();
	};
	my.d.Position.delta = {
		x: 0,
		y: 0,
		z: 0
	};
	my.d.Position.deltaPathPlace = 0;
	my.d.Position.pathSpeedConstant = true;
	my.mergeInto(my.d.Cell, my.d.Position);
	my.mergeInto(my.d.Sprite, my.d.Position);
	if (my.xt(my.d.Block)) {
		my.mergeInto(my.d.Block, my.d.Sprite);
	}
	if (my.xt(my.d.Shape)) {
		my.mergeInto(my.d.Shape, my.d.Sprite);
	}
	if (my.xt(my.d.Wheel)) {
		my.mergeInto(my.d.Wheel, my.d.Sprite);
	}
	if (my.xt(my.d.Picture)) {
		my.mergeInto(my.d.Picture, my.d.Sprite);
	}
	if (my.xt(my.d.Phrase)) {
		my.mergeInto(my.d.Phrase, my.d.Sprite);
	}
	if (my.xt(my.d.Path)) {
		my.mergeInto(my.d.Path, my.d.Sprite);
	}
	/**
Position constructor hook function

Adds a __delta__ (deltaX, deltaY) Vector to the object, used to give an object a &#x27;velocity&#x27;

@method animationPositionInit
@private
**/
	my.Position.prototype.animationPositionInit = function(items) {
		var temp = my.safeObject(items.delta);
		this.delta = my.newVector({
			x: (my.xt(items.deltaX)) ? items.deltaX : ((my.xt(temp.x)) ? temp.x : 0),
			y: (my.xt(items.deltaY)) ? items.deltaY : ((my.xt(temp.y)) ? temp.y : 0),
		});
		this.work.delta = my.newVector({
			name: this.type + &#x27;.&#x27; + this.name + &#x27;.work.delta&#x27;
		});
		this.pathSpeedConstant = (my.isa(items.pathSpeedConstant, &#x27;bool&#x27;)) ? items.pathSpeedConstant : my.d[this.type].pathSpeedConstant;
		this.deltaPathPlace = items.deltaPathPlace || my.d[this.type].deltaPathPlace;
	};
	/**
Position.get hook function - modified by animation module
@method animationPositionGet
@private
**/
	my.Position.prototype.animationPositionGet = function(item) {
		if (my.contains([&#x27;deltaX&#x27;, &#x27;deltaY&#x27;], item)) {
			switch (item) {
				case &#x27;deltaX&#x27;:
					return this.delta.x;
				case &#x27;deltaY&#x27;:
					return this.delta.y;
			}
		}
		if (&#x27;delta&#x27; === item) {
			console.log(this.name, &#x27;get delta vector&#x27;);
			return this.delta.getVector();
		}
		return false;
	};
	/**
Position.set hook function - modified by animation module
@method animationPositionSet
@private
**/
	my.Position.prototype.animationPositionSet = function(items) {
		if (!my.isa(this.delta, &#x27;vector&#x27;)) {
			this.delta = my.newVector(items.delta || this.delta);
		}
		if (my.xto([items.deltaX, items.deltaY])) {
			this.delta.x = (my.xt(items.deltaX)) ? items.deltaX : this.delta.x;
			this.delta.y = (my.xt(items.deltaY)) ? items.deltaY : this.delta.y;
		}
	};
	/**
Position.setDelta hook function - modified by animation module
@method animationPositionClone
@private
**/
	my.Position.prototype.animationPositionClone = function(a, items) {
		var temp = my.safeObject(items.delta);
		a.delta = my.newVector({
			x: (my.xt(items.deltaX)) ? items.deltaX : ((my.xt(temp.x)) ? temp.x : a.delta.x),
			y: (my.xt(items.deltaY)) ? items.deltaY : ((my.xt(temp.y)) ? temp.y : a.delta.y),
		});
		return a;
	};
	/**
Adds delta values to the start vector; adds deltaPathPlace to pathPlace

Permitted argument values include 
* &#x27;x&#x27; - delta.x added to start.x
* &#x27;y&#x27; - delta.y added to start.y
* &#x27;path&#x27; - deltaPathPlace added to pathPlace 
* undefined: all values are amended
@method Position.updateStart
@param {String} [item] String used to limit this function&#x27;s actions - permitted values include &#x27;x&#x27;, &#x27;y&#x27;, &#x27;path&#x27;; default action: all values are amended
@return This
@chainable
**/
	my.Position.prototype.updateStart = function(item) {
		switch (item) {
			case &#x27;x&#x27;:
				this.start.x += this.delta.x || 0;
				break;
			case &#x27;y&#x27;:
				this.start.y += this.delta.y || 0;
				break;
			case &#x27;path&#x27;:
				this.pathPlace += this.deltaPathPlace;
				if (this.pathPlace &gt; 1) {
					this.pathPlace -= 1;
				}
				if (this.pathPlace &lt; 0) {
					this.pathPlace += 1;
				}
				break;
			default:
				this.pathPlace += this.deltaPathPlace;
				if (this.pathPlace &gt; 1) {
					this.pathPlace -= 1;
				}
				if (this.pathPlace &lt; 0) {
					this.pathPlace += 1;
				}
				this.start.vectorAdd(this.delta);
		}
		return this;
	};
	/**
Subtracts delta values from the start vector; subtracts deltaPathPlace from pathPlace

Permitted argument values include 
* &#x27;x&#x27; - delta.x subtracted from start.x
* &#x27;y&#x27; - delta.y subtracted from start.y
* &#x27;path&#x27; - deltaPathPlace subtracted from pathPlace 
* undefined: all values are amended
@method Position.revertStart
@param {String} [item] String used to limit this function&#x27;s actions - permitted values include &#x27;x&#x27;, &#x27;y&#x27;, &#x27;path&#x27;; default action: all values are amended
@return This
@chainable
**/
	my.Position.prototype.revertStart = function(item) {
		switch (item) {
			case &#x27;x&#x27;:
				this.start.x -= this.delta.x || 0;
				break;
			case &#x27;y&#x27;:
				this.start.y -= this.delta.y || 0;
				break;
			case &#x27;path&#x27;:
				this.pathPlace -= this.deltaPathPlace;
				if (this.pathPlace &gt; 1) {
					this.pathPlace -= 1;
				}
				if (this.pathPlace &lt; 0) {
					this.pathPlace += 1;
				}
				break;
			default:
				this.pathPlace += this.deltaPathPlace;
				if (this.pathPlace &gt; 1) {
					this.pathPlace -= 1;
				}
				if (this.pathPlace &lt; 0) {
					this.pathPlace += 1;
				}
				this.start.vectorSubtract(this.delta);
		}
		return this;
	};
	/**
Swaps the values of an attribute between two objects
@method Position.exchange
@param {Object} obj Object with which this object will swap attribute values
@param {String} item Attribute to be swapped
@return This
@chainable
**/
	my.Position.prototype.exchange = function(obj, item) {
		if (my.isa(obj, &#x27;obj&#x27;)) {
			var temp = this[item] || this.get(item);
			this[item] = obj[item] || obj.get(item);
			obj[item] = temp;
		}
		return this;
	};
	/**
Changes the sign (+/-) of specified attribute values
@method Position.reverse
@param {String} [item] String used to limit this function&#x27;s actions - permitted values include &#x27;deltaX&#x27;, &#x27;deltaY&#x27;, &#x27;delta&#x27;, &#x27;deltaPathPlace&#x27;; default action: all values are amended
@return This
@chainable
**/
	my.Position.prototype.reverse = function(item) {
		switch (item) {
			case &#x27;deltaX&#x27;:
				this.delta.x = -this.delta.x;
				break;
			case &#x27;deltaY&#x27;:
				this.delta.y = -this.delta.y;
				break;
			case &#x27;delta&#x27;:
				this.delta.reverse();
				break;
			case &#x27;deltaPathPlace&#x27;:
				this.deltaPathPlace = -this.deltaPathPlace;
				break;
			default:
				this.deltaPathPlace = -this.deltaPathPlace;
				this.delta.reverse();
		}
		return this;
	};
	my.d.Cell.sourceDelta = {
		x: 0,
		y: 0,
		z: 0
	};
	my.d.Cell.sourceMinWidth = 0;
	my.d.Cell.sourceMaxWidth = 0;
	my.d.Cell.sourceMinHeight = 0;
	my.d.Cell.sourceMaxHeight = 0;
	/**
Cell constructor hook function

Adds a __sourceDelta__ (sourceDeltaX, sourceDeltaY) Vector to the cell, used to give it a &#x27;velocity&#x27;

@method animationCellInit
@private
**/
	my.Cell.prototype.animationCellInit = function(items) {
		var temp = my.safeObject(items.sourceDelta);
		this.sourceDelta = my.newVector({
			x: (my.xt(items.sourceDeltaX)) ? items.sourceDeltaX : ((my.xt(temp.x)) ? temp.x : 0),
			y: (my.xt(items.sourceDeltaY)) ? items.sourceDeltaY : ((my.xt(temp.y)) ? temp.y : 0),
		});
		this.work.sourceDelta = my.newVector();
	};
	/**
Cell.get hook function - modified by animation module
@method animationCellGet
@private
**/
	my.Cell.prototype.animationCellGet = function(item) {
		if (my.contains([&#x27;sourceDeltaX&#x27;, &#x27;sourceDeltaY&#x27;], item)) {
			switch (item) {
				case &#x27;sourceDeltaX&#x27;:
					return this.sourceDelta.x;
				case &#x27;sourceDeltaY&#x27;:
					return this.sourceDelta.y;
			}
		}
		return my.Base.prototype.get.call(this, item);
	};
	/**
Cell.set hook function - modified by animation module
@method animationCellSet
@private
**/
	my.Cell.prototype.animationCellSet = function(items) {
		var temp;
		if (my.xto([items.sourceDelta, items.sourceDeltaX, items.sourceDeltaY])) {
			temp = my.safeObject(items.sourceDelta);
			this.sourceDelta.x = items.sourceDeltaX || temp.x || this.sourceDelta.x;
			this.sourceDelta.y = items.sourceDeltaY || temp.y || this.sourceDelta.y;
		}
	};
	/**
Adds delta values to the start vector; adds sourceDelta values to the source vector; adds deltaPathPlace to pathPlace

Permitted argument values include 
* &#x27;x&#x27; - delta.x added to start.x; deltaSource.x added to source.x
* &#x27;y&#x27; - delta.y added to start.y; deltaSource.y added to source.y
* &#x27;start&#x27;, &#x27;target&#x27; - delta added to start
* &#x27;source&#x27; - deltaSource added to source
* &#x27;path&#x27; - deltaPathPlace added to pathPlace 
* undefined: all values are amended
@method Cell.updateStart
@param {String} [item] String used to limit this function&#x27;s actions
@return This
@chainable
**/
	my.Cell.prototype.updateStart = function(item) {
		switch (item) {
			case &#x27;x&#x27;:
				this.start.x += this.delta.x || 0;
				this.source.x += this.deltaSource.x || 0;
				break;
			case &#x27;y&#x27;:
				this.start.y += this.delta.y || 0;
				this.source.y += this.deltaSource.y || 0;
				break;
			case &#x27;start&#x27;:
			case &#x27;target&#x27;:
				this.start.vectorAdd(this.delta);
				break;
			case &#x27;source&#x27;:
				this.source.vectorAdd(this.sourceDelta);
				break;
			case &#x27;path&#x27;:
				this.pathPlace += this.deltaPathPlace || 0;
				if (this.pathPlace &gt; 1) {
					this.pathPlace -= 1;
				}
				if (this.pathPlace &lt; 0) {
					this.pathPlace += 1;
				}
				break;
			default:
				if (my.xt(this.pathPlace)) {
					this.pathPlace += this.deltaPathPlace || 0;
					if (this.pathPlace &gt; 1) {
						this.pathPlace -= 1;
					}
					if (this.pathPlace &lt; 0) {
						this.pathPlace += 1;
					}
				}
				this.start.vectorAdd(this.delta);
				this.source.vectorAdd(this.sourceDelta);
		}
		return this;
	};
	/**
Subtracts delta values from the start vector; subtracts sourceDelta values from the source vector; subtracts deltaPathPlace to pathPlace

Permitted argument values include 
* &#x27;x&#x27; - delta.x subtracted from start.x; deltaSource.x subtracted from source.x
* &#x27;y&#x27; - delta.y subtracted from start.y; deltaSource.y subtracted from source.y
* &#x27;start&#x27;, &#x27;target&#x27; - delta subtracted from start
* &#x27;source&#x27; - deltaSource subtracted from source
* &#x27;path&#x27; - deltaPathPlace subtracted from pathPlace 
* undefined: all values are amended
@method Cell.revertStart
@param {String} [item] String used to limit this function&#x27;s actions
@return This
@chainable
**/
	my.Cell.prototype.revertStart = function(item) {
		switch (item) {
			case &#x27;x&#x27;:
				this.start.x -= this.delta.x || 0;
				this.source.x -= this.deltaSource.x || 0;
				break;
			case &#x27;y&#x27;:
				this.start.y -= this.delta.y || 0;
				this.source.y -= this.deltaSource.y || 0;
				break;
			case &#x27;start&#x27;:
			case &#x27;target&#x27;:
				this.start.vectorSubtract(this.delta);
				break;
			case &#x27;source&#x27;:
				this.source.vectorSubtract(this.sourceDelta);
				break;
			case &#x27;path&#x27;:
				this.pathPlace -= this.deltaPathPlace || 0;
				if (this.pathPlace &gt; 1) {
					this.pathPlace -= 1;
				}
				if (this.pathPlace &lt; 0) {
					this.pathPlace += 1;
				}
				break;
			default:
				if (my.xt(this.pathPlace)) {
					this.pathPlace -= this.deltaPathPlace || 0;
					if (this.pathPlace &gt; 1) {
						this.pathPlace -= 1;
					}
					if (this.pathPlace &lt; 0) {
						this.pathPlace += 1;
					}
				}
				this.start.vectorSubtract(this.delta);
				this.source.vectorSubtract(this.sourceDelta);
		}
		return this;
	};
	/**
Zooms one cell in relation to another cell
@method Cell.zoom
@param {Number} item Number of pixels to amend the zoomed cell&#x27;s start and dimensions by
@return This
@chainable
**/
	my.Cell.prototype.zoom = function(item) {
		if (my.isa(item, &#x27;num&#x27;)) {
			var sWidth = this.sourceWidth,
				sHeight = this.sourceHeight,
				aWidth = this.actualWidth,
				aHeight = this.actualHeight,
				minWidth = this.get(&#x27;sourceMinWidth&#x27;) || this.sourceWidth,
				minHeight = this.get(&#x27;sourceMinHeight&#x27;) || this.sourceHeight,
				maxWidth = this.get(&#x27;sourceMaxWidth&#x27;) || this.sourceWidth,
				maxHeight = this.get(&#x27;sourceMaxHeight&#x27;) || this.sourceHeight,
				sx = this.source.x,
				sy = this.source.y,
				myW = sWidth + item,
				myH = sHeight + item,
				myX,
				myY;
			if (my.isBetween(myW, minWidth, maxWidth, true) &amp;&amp; my.isBetween(myH, minHeight, maxHeight, true)) {
				sWidth = myW;
				myX = sx - (item / 2);
				if (myX &lt; 0) {
					sx = 0;
				}
				else if (myX &gt; (aWidth - sWidth)) {
					sx = aWidth - sWidth;
				}
				else {
					sx = myX;
				}
				sHeight = myH;
				myY = sy - (item / 2);
				if (myY &lt; 0) {
					sy = 0;
				}
				else if (myY &gt; (aHeight - sHeight)) {
					sy = aHeight - sHeight;
				}
				else {
					sy = myY;
				}
				this.source.x = sx;
				this.source.y = sy;
				this.sourceWidth = sWidth;
				this.sourceHeight = sHeight;
			}
		}
		return this;
	};
	/**
Perform a splice-shift-join operation on the &amp;lt;canvas&amp;gt; element&#x27;s current scene

Argument is an Object in the form:

* {edge:String, strip:Number}

Permitted values for the argument Object&#x27;s attributes are:

* __edge__ - one from &#x27;horizontal&#x27;, &#x27;vertical&#x27;, &#x27;top&#x27;, &#x27;bottom&#x27;, &#x27;left&#x27;, &#x27;right&#x27;
* __strip__ - a width/height Number (in pixels) of the strip that is to be moved from the named edge of the &amp;lt;canvas&amp;gt; to the opposite edge

_Note that this function is only effective in achieving a parallax effect if the user never clears or updates the cell&#x27;s &amp;lt;canvas&amp;gt; element, and takes steps to shift the cell&#x27;s source vector appropriately each time the splice operation is performed_

@method Cell.spliceCell
@param {Object} items Object containing data for the splice operation
@return This
@chainable
**/
	my.Cell.prototype.spliceCell = function(items) {
		items = my.safeObject(items);
		if (my.contains([&#x27;horizontal&#x27;, &#x27;vertical&#x27;, &#x27;top&#x27;, &#x27;bottom&#x27;, &#x27;left&#x27;, &#x27;right&#x27;], items.edge)) {
			var myStrip,
				myRemains,
				myEdge,
				height = this.actualHeight,
				width = this.actualWidth,
				c,
				e,
				canvas = my.canvas[this.name],
				ctx = my.context[this.name];
			c = document.createElement(&#x27;canvas&#x27;);
			c.width = width;
			c.height = height;
			e = c.getContext(&#x27;2d&#x27;);
			ctx.setTransform(1, 0, 0, 1, 0, 0);
			switch (items.edge) {
				case &#x27;horizontal&#x27;:
					myStrip = myRemains = width / 2;
					myEdge = &#x27;left&#x27;;
					break;
				case &#x27;vertical&#x27;:
					myStrip = myRemains = height / 2;
					myEdge = &#x27;top&#x27;;
					break;
				case &#x27;top&#x27;:
				case &#x27;bottom&#x27;:
					myStrip = items.strip || 20;
					myRemains = height - myStrip;
					myEdge = items.edge;
					break;
				case &#x27;left&#x27;:
				case &#x27;right&#x27;:
					myStrip = items.strip || 20;
					myRemains = width - myStrip;
					myEdge = items.edge;
					break;
			}
			switch (myEdge) {
				case &#x27;top&#x27;:
					e.drawImage(canvas, 0, 0, width, myStrip, 0, myRemains, width, myStrip);
					e.drawImage(canvas, 0, myStrip, width, myRemains, 0, 0, width, myRemains);
					break;
				case &#x27;bottom&#x27;:
					e.drawImage(canvas, 0, 0, width, myRemains, 0, myStrip, width, myRemains);
					e.drawImage(canvas, 0, myRemains, width, myStrip, 0, 0, width, myStrip);
					break;
				case &#x27;left&#x27;:
					e.drawImage(canvas, 0, 0, myStrip, height, myRemains, 0, myStrip, height);
					e.drawImage(canvas, myStrip, 0, myRemains, height, 0, 0, myRemains, height);
					break;
				case &#x27;right&#x27;:
					e.drawImage(canvas, 0, 0, myRemains, height, myStrip, 0, myRemains, height);
					e.drawImage(canvas, myRemains, 0, myStrip, height, 0, 0, myStrip, height);
					break;
			}
			ctx.clearRect(0, 0, width, height);
			ctx.drawImage(c, 0, 0, width, height);
		}
		return this;
	};
	/**
Ask all sprites in the Group to perform an updateStart() operation

Each sprite will add their delta values to their start Vector, and/or add deltaPathPlace from pathPlace
@method Group.updateStart
@param {String} [item] String used to limit this function&#x27;s actions - permitted values include &#x27;x&#x27;, &#x27;y&#x27;, &#x27;path&#x27;; default action: all values are amended
@return This
@chainable
**/
	my.Group.prototype.updateStart = function(item) {
		for (var i = 0, z = this.sprites.length; i &lt; z; i++) {
			my.sprite[this.sprites[i]].updateStart(item);
		}
		return this;
	};
	/**
Ask all sprites in the Group to perform a revertStart() operation

Each sprite will subtract their delta values to their start Vector, and/or subtract deltaPathPlace from pathPlace
@method Group.revertStart
@param {String} [item] String used to limit this function&#x27;s actions - permitted values include &#x27;x&#x27;, &#x27;y&#x27;, &#x27;path&#x27;; default action: all values are amended
@return This
@chainable
**/
	my.Group.prototype.revertStart = function(item) {
		for (var i = 0, z = this.sprites.length; i &lt; z; i++) {
			my.sprite[this.sprites[i]].revertStart(item);
		}
		return this;
	};
	/**
Ask all sprites in the group to perform a reverse() operation

Each sprite will change the sign (+/-) of specified attribute values
@method Group.reverse
@param {String} [item] String used to limit this function&#x27;s actions - permitted values include &#x27;deltaX&#x27;, &#x27;deltaY&#x27;, &#x27;delta&#x27;, &#x27;deltaPathPlace&#x27;; default action: all values are amended
@return This
@chainable
**/
	my.Group.prototype.reverse = function(item) {
		for (var i = 0, z = this.sprites.length; i &lt; z; i++) {
			my.sprite[this.sprites[i]].reverse(item);
		}
		return this;
	};
	my.d.Design.roll = 0;
	my.d.Design.autoUpdate = false;
	my.mergeInto(my.d.Gradient, my.d.Design);
	my.mergeInto(my.d.RadialGradient, my.d.Design);
	if (my.xt(my.d.Pattern)) {
		my.mergeInto(my.d.Pattern, my.d.Design);
	}
	/**
Creates the gradient

_This function replaces the one in the core module_
@method Design.update
@param {String} [sprite] SPRITENAME String
@param {String} [cell] CELLNAME String
@return This
@chainable
**/
	my.Design.prototype.update = function(sprite, cell) {
		this.makeGradient(sprite, cell);
		this.sortStops();
		this.applyStops();
		return this;
	};
	/**
Gradient builder helper function - sorts color attribute Objects by their stop attribute values, after adding the roll value to them
@method Design.sortStops
@return Nothing
@private
**/
	my.Design.prototype.sortStops = function() {
		var color = this.get(&#x27;color&#x27;),
			roll = this.get(&#x27;roll&#x27;);
		for (var i = 0, z = color.length; i &lt; z; i++) {
			color[i].stop += roll;
			if (!my.isBetween(color[i].stop, 0, 1, true)) {
				color[i].stop = (color[i].stop &gt; 0.5) ? color[i].stop - 1 : color[i].stop + 1;
			}
			if (color[i].stop &lt;= 0) {
				color[i].stop = 0.000001;
			}
			else if (color[i].stop &gt;= 1) {
				color[i].stop = 0.999999;
			}
		}
		color.sort(function(a, b) {
			return a.stop - b.stop;
		});
		this.set({
			color: color,
		});
	};
	/**
A __factory__ function to generate new Animation objects
@method newAnimation
@param {Object} items Key:value Object argument for setting attributes
@return Animation object
**/
	my.newAnimation = function(items) {
		return new my.Animation(items);
	};
	/**
A __factory__ function to generate new Tween objects
@method newTween
@param {Object} items Key:value Object argument for setting attributes
@return Tween object
**/
	my.newTween = function(items) {
		return new my.Tween(items);
	};
	my.pushUnique(my.sectionlist, &#x27;animation&#x27;);
	my.pushUnique(my.nameslist, &#x27;animate&#x27;);
	my.pushUnique(my.nameslist, &#x27;animationnames&#x27;);
	/**
Animation flag: set to false to stop animation loop
@property doAnimation
@type {Boolean}
**/
	my.doAnimation = false;
	/**
Animation ordering flag - when set to false, the ordering of animations is skipped; default: true
@property orderAnimations
@type {Boolean}
@default true
**/
	my.orderAnimations = true;
	/**
The Scrawl animation loop

Animation loop is invoked automatically as part of the initialization process

Scrawl will run all Animation objects whose ANIMATIONNAME Strings are included in the __scrawl.animate__ Array

All animation can be halted by setting the __scrawl.doAnimation__ flag to false

To restart animation, either call __scrawl.initialize()__, or set _scrawl.doAnimation_ to true and call __scrawl.animationLoop()

@method animationLoop
@return Recursively calls itself - never returns
**/
	my.animationLoop = function() {
		if (my.orderAnimations) {
			my.sortAnimations();
		}
		for (var i = 0, iz = my.animate.length; i &lt; iz; i++) {
			if (my.animate[i]) {
				my.animation[my.animate[i]].fn();
			}
		}
		if (my.doAnimation) {
			window.requestAnimFrame(function() {
				my.animationLoop();
			});
		}
	};
	/**
Animation sorting routine - animation objects are sorted according to their animation.order attribute value, in ascending order
@method sortAnimations
@return Nothing
@private
**/
	my.sortAnimations = function() {
		my.animate.sort(function(a, b) {
			return my.animation[a].order - my.animation[b].order;
		});
	};

	/**
# Animation

## Instantiation

* scrawl.newAnimation()

## Purpose

* Defines an animation function to be run by the scrawl.animationLoop() function

## Access

* scrawl.animation.ANIMATIONNAME - for the Animation object

@class Animation
@constructor
@extends Base
@param {Object} [items] Key:value Object argument for setting attributes
**/
	my.Animation = function(items) {
		my.Base.call(this, items);
		items = my.safeObject(items);
		var delay = (my.isa(items.delay, &#x27;bool&#x27;)) ? items.delay : false;
		this.fn = items.fn || function() {};
		this.order = items.order || 0;
		my.animation[this.name] = this;
		my.pushUnique(my.animationnames, this.name);
		/**
Pseudo-attribute used to prevent immediate running of animation when first created

_This attribute is not retained by the Animation object_
@property delay
@type Boolean
@default false
**/
		if (!delay) {
			this.run();
		}
		return this;
	};
	my.Animation.prototype = Object.create(my.Base.prototype);
	/**
@property type
@type String
@default &#x27;Animation&#x27;
@final
**/
	my.Animation.prototype.type = &#x27;Animation&#x27;;
	my.Animation.prototype.classname = &#x27;animationnames&#x27;;
	my.d.Animation = {
		/**
Anonymous function for an animation routine
@property fn
@type Function
@default function(){}
**/
		fn: function() {},
		/**
Lower order animations are run during each frame before higher order ones
@property order
@type Number
@default 0
**/
		order: 0,
	};
	my.mergeInto(my.d.Animation, my.d.Base);
	/**
Run an animation
@method run
@return Always true
**/
	my.Animation.prototype.run = function() {
		my.pushUnique(my.animate, this.name);
		return true;
	};
	/**
Stop an animation
@method halt
@return Always true
**/
	my.Animation.prototype.halt = function() {
		my.removeItem(my.animate, this.name);
		return true;
	};
	/**
Remove this Animation from the scrawl library
@method kill
@return Always true
**/
	my.Animation.prototype.kill = function() {
		delete my.animation[this.name];
		my.removeItem(my.animationnames, this.name);
		my.removeItem(my.animate, this.name);
		return true;
	};

	/**
# Tween

## Instantiation

* scrawl.newTween()

## Purpose

* Defines an animation to be applied to a Scrawl object

Tweens are animations defined by duration (how long they should run for) and distance (how much an attribute needs to change over the course of the tween).

* One tween can change several attributes of an object, and can apply these changes to one or more objects as the tween runs its course.
* Any attribute that holds a Number type value can be tweened
* The starting point for each attribute tween is set in the __start__ attribute object
* The ending point for each attribute tween is set in the __end__ attribute object
* If an ending point is defined for an attribute, but no starting point, then the tween will use the object&#x27;s attribute&#x27;s current value for the starting point.
* Individual _easing engines_ can be defined for each attribute in the __engines__ attribute object.

The objects on which the tween will operate are passed to the tween as an array of objects, in the __targets__ attribute

* A tween will only run on an object that is not currently being animated by another tween
* A tween cannot be run if it is already running.

The duration of the tween is set in the __duration__ attribute, in milliseconds.

Tweens can hold data for attribute changes to be applied to their object(s) before the tween starts(__onCommence__) and after the tween ends (__onComplete__).

Tweens can be chained by setting the __nextTween__ attribute to the String _name_ attribute of the next tween to be run.

Tweens come with a number of flags and attributes to indicate how many times they should be run before completing:

* Set the __count__ attribute to a positive integer to run the tween that many times. Setting the attribute to _true_ will run the tween forever
* Tween direction can be reversed by setting the __reverse__ flag to _true_
* Setting the __autoReverse__ flag to true will automatically reverse the tween&#x27;s direction at the end of each run
* Setting the __autoReverseAndRun__ reverses the tween&#x27;s direction and immediately running it again.

## Access

* scrawl.animation.TWEENNAME - for the Tween object

## Tween functions

* Start a tween by calling the __run()__ function on it.
* Tween animation can be stopped by calling the __halt()__ function on it.
* A Tween can be deleted by calling the __kill()__ function on it.

@class Tween
@constructor
@extends Base
@param {Object} [items] Key:value Object argument for setting attributes
**/
	my.Tween = function(items) {
		my.Base.call(this, items);
		items = my.safeObject(items);
		this.targets = (my.isa(items.targets, &#x27;arr&#x27;)) ? items.targets : ((my.xt(items.targets)) ? [items.targets] : []);
		this.currentTargets = [];
		this.initVals = [];
		this.start = (my.isa(items.start, &#x27;obj&#x27;)) ? items.start : {};
		this.engines = (my.isa(items.engines, &#x27;obj&#x27;)) ? items.engines : {};
		this.end = (my.isa(items.end, &#x27;obj&#x27;)) ? items.end : {};
		this.startTime = Date.now();
		this.duration = items.duration || 0;
		this.active = false;
		this.reverse = items.reverse || false;
		this.autoReverse = items.autoReverse || false;
		this.autoReverseAndRun = items.autoReverseAndRun || false;
		this.count = items.count || 0;
		this.currentCount = 0;
		this.onCommence = items.onCommence || {};
		this.onComplete = items.onComplete || {};
		this.nextTween = items.nextTween || &#x27;&#x27;;
		this.killOnComplete = items.killOnComplete || false;
		this.callback = (my.isa(items.callback, &#x27;fn&#x27;)) ? items.callback : false;
		this.order = items.order || 0;
		my.animation[this.name] = this;
		my.pushUnique(my.animationnames, this.name);
		return this;
	};
	my.Tween.prototype = Object.create(my.Base.prototype);
	/**
@property type
@type String
@default &#x27;Tween&#x27;
@final
**/
	my.Tween.prototype.type = &#x27;Tween&#x27;;
	my.Tween.prototype.classname = &#x27;animationnames&#x27;;
	my.d.Tween = {
		/**
Array of sprites, cells, etc to be animated using this tween; expects to be passed handles to the sprite objects, not SPRITENAME strings
@property targets
@type Array
@default []
**/
		targets: [],
		/**
Array of sprites, cells, etc currently being animated using this tween
@property currentTargets
@type Array
@default []
@private
**/
		currentTargets: [],
		/**
Object containing the start positions (for absolute transitions) or delta values (for relative transitions) for given settable (ie: Number) attributes
@property start
@type Object
@default {}
**/
		start: {},
		/**
Object containing attribute: value pairs determining which easing engine will be applied to each tweened attribute

Currently, Scrawl offers the following easing engines. _Out_ signifies that the end of the tween is faster than the start; _In_ signifies the the end of the tween is slower. (This is the opposite of &#x27;Flash&#x27; usage, but in line with wider programming conventions):

* __in__, __easeIn__, __easeIn3__, __easeIn4__, __easeIn5__
* __out__, __easeOut__, __easeOut3__, __easeOut4__, __easeOut5__
* __easeOutIn__, __easeOutIn3__, __easeOutIn4__, __easeOutIn5__
* __linear__ (default) - an even speed throughout the duration of the tween
@property engines
@type Object
@default {}
**/
		engines: {},
		/**
Object containing the end positions for given settable (ie: Number) attributes
@property end
@type Object
@default {}
**/
		end: {},
		/**
Object containing set instructions to be performed at the end of the tween
@property onComplete
@type Object
@default {}
**/
		onComplete: {},
		/**
Object containing runtime initial values for each object being tweened
@property initVals
@type Object
@default {}
@private
**/
		initVals: [],
		/**
Object containing set instructions to be performed at the start of the tween
@property onCommence
@type Object
@default {}
**/
		onCommence: {},
		/**
Datetime when the tween starts running
@property startTime
@type Number - Date.now()
@default 0
@private
**/
		startTime: 0,
		/**
Duration of the tween, measured in milliseconds
@property duration
@type Number
@default 0
**/
		duration: 0,
		/**
Flag - when true, tween is running
@property active
@type Boolean
@default false
@private
**/
		active: false,
		/**
Flag - when true, tween runs in reverse, from end values to start values (for absolute transitions) or applying negative start values (for relative transitions)
@property reverse
@type Boolean
@default false
**/
		reverse: false,
		/**
Flag - when true, tween will automatically reverse its direction when it completes
@property autoReverse
@type Boolean
@default false
**/
		autoReverse: false,
		/**
Callback function to run when tween completes - will not run if nextTween is set
@property callback
@type Function
@default false
**/
		callback: false,
		/**
Flag - when true, tween will automatically reverse its direction when it completes, and immediately run again
@property autoReverseAndRun
@type Boolean
@default false
**/
		autoReverseAndRun: false,
		/**
Counter for the number of cycles the tween will run; set to true for countinuous repetition
@property count
@type Mixed - Number or Boolean
@default 0
**/
		count: 0,
		/**
Internal attribute
@property currentCount
@type Mixed - Number or Boolean
@default 0
@private
**/
		currentCount: 0,
		/**
Flag - when true, tween will automatically delete itself when it completes
@property killOnComplete
@type Boolean
@default false
**/
		killOnComplete: false,
		/**
TWEENNAME Sring of the tween to be run when this tween completes
@property nextTween
@type String
@default &#x27;&#x27;
**/
		nextTween: &#x27;&#x27;,
		/**
Lower order animations are run during each frame before higher order ones
@property order
@type Number
@default 0
**/
		order: 0,
	};
	my.mergeInto(my.d.Tween, my.d.Base);
	/**
Tween animation function
@method fn
@return Always true
@private
**/
	my.Tween.prototype.fn = function() {
		var currentTime = Date.now(),
			progress = (currentTime - this.startTime) / this.duration,
			sprite,
			argSet,
			keys = Object.keys(this.end);
		if (this.active) {
			if (progress &lt; 1) {
				for (var t = 0, tz = this.currentTargets.length; t &lt; tz; t++) {
					sprite = this.currentTargets[t];
					if (my.xt(sprite)) {
						argSet = {};
						for (var k = 0, kz = keys.length; k &lt; kz; k++) {
							argSet[keys[k]] = this.engine(this.initVals[t][keys[k]].start,
								this.initVals[t][keys[k]].change,
								progress,
								this.engines[keys[k]],
								this.reverse);
						}
						sprite.set(argSet);
					}
				}
			}
			else {
				this.halt();
				if (this.autoReverse || this.autoReverseAndRun) {
					this.reverse = (this.reverse) ? false : true;
				}
				if (this.autoReverseAndRun) {
					if (my.isa(this.currentCount, &#x27;num&#x27;)) {
						this.currentCount--;
						if (this.currentCount &gt; 0) {
							this.run();
						}
						else {
							this.runComplete();
						}
					}
					else {
						this.run();
					}
				}
				else {
					this.runComplete();
				}
			}
		}
		return true;
	};
	/**
Tween engines
@method engine
@return calculated current value for an attribute, which will vary depending on which engine has been selected 
@param {Number} start Start point for tween action
@param {Number} change Total change required for tween action
@param {Number} position Normalized time (time elapsed/duration)
@param {String} engine Calculation engine to be used
@param {Boolean} reverse Reverse flag - true if tween is reversed
@private
**/
	my.Tween.prototype.engine = function(start, change, position, engine, reverse) {
		var temp;
		switch (engine) {
			case &#x27;easeOut&#x27;: //OPPOSITE of Flash easeOut - slow at start, not end
				return start + ((position * position) * change);
			case &#x27;easeIn&#x27;: //OPPOSITE of Flash easeIn - slow at end, not start
				temp = 1 - position;
				return (start + change) + ((temp * temp) * -change);
			case &#x27;easeOut3&#x27;:
				return start + ((position * position * position) * change);
			case &#x27;easeIn3&#x27;:
				temp = 1 - position;
				return (start + change) + ((temp * temp * temp) * -change);
			case &#x27;easeOut4&#x27;:
				return start + ((position * position * position * position) * change);
			case &#x27;easeIn4&#x27;:
				temp = 1 - position;
				return (start + change) + ((temp * temp * temp * temp) * -change);
			case &#x27;easeOut5&#x27;:
				return start + ((position * position * position * position * position) * change);
			case &#x27;easeIn5&#x27;:
				temp = 1 - position;
				return (start + change) + ((temp * temp * temp * temp * temp) * -change);
			case &#x27;easeOutIn&#x27;:
				temp = 1 - position;
				return (position &lt; 0.5) ?
					start + ((position * position) * change * 2) :
					(start + change) + ((temp * temp) * -change * 2);
			case &#x27;easeOutIn3&#x27;:
				temp = 1 - position;
				return (position &lt; 0.5) ?
					start + ((position * position * position) * change * 4) :
					(start + change) + ((temp * temp * temp) * -change * 4);
			case &#x27;easeOutIn4&#x27;:
				temp = 1 - position;
				return (position &lt; 0.5) ?
					start + ((position * position * position * position) * change * 8) :
					(start + change) + ((temp * temp * temp * temp) * -change * 8);
			case &#x27;easeOutIn5&#x27;:
				temp = 1 - position;
				return (position &lt; 0.5) ?
					start + ((position * position * position * position * position) * change * 16) :
					(start + change) + ((temp * temp * temp * temp * temp) * -change * 16);
			case &#x27;out&#x27;:
				temp = 1 - position;
				return (start + change) + (Math.cos((position * 90) * my.radian) * -change);
			case &#x27;in&#x27;:
				return start + (Math.sin((position * 90) * my.radian) * change);
			default:
				return start + (position * change);
		}
	};
	/**
Run a tween animation
@method run
@return Always true
**/
	my.Tween.prototype.run = function() {
		var test,
			activeTweens,
			tw,
			keys,
			start,
			change;
		if (!this.active) {
			activeTweens = [];
			keys = Object.keys(this.end);
			this.currentCount = this.currentCount || this.count;
			this.currentTargets = [];
			this.initVals = [];
			for (var l = 0, lz = my.animationnames.length; l &lt; lz; l++) {
				tw = my.animation[my.animationnames[l]];
				if (tw.type === &#x27;Tween&#x27; &amp;&amp; tw.active &amp;&amp; tw.name !== this.name) {
					activeTweens.push(tw);
				}
			}
			for (var i = 0, iz = this.targets.length; i &lt; iz; i++) {
				test = true;
				for (var j = 0, jz = activeTweens.length; j &lt; jz; j++) {
					for (var k = 0, kz = activeTweens[j].currentTargets.length; k &lt; kz; k++) {
						if (this.targets[i].name === activeTweens[j].currentTargets[k].name) {
							test = false;
							break;
						}
					}
					if (!test) {
						break;
					}
				}
				if (test) {
					this.currentTargets.push(this.targets[i]);
				}
			}
			if (this.currentTargets.length &gt; 0) {
				for (var t = 0, tz = this.currentTargets.length; t &lt; tz; t++) {
					if (my.xt(this.currentTargets[t])) {
						this.currentTargets[t].set(this.onCommence);
						this.initVals.push({});
						for (var m = 0, mz = keys.length; m &lt; mz; m++) {
							if (my.xt(this.start[keys[m]])) {
								this.initVals[t][keys[m]] = {
									start: (this.reverse) ? this.end[keys[m]] : this.start[keys[m]],
									change: (this.reverse) ? -(this.end[keys[m]] - this.start[keys[m]]) : this.end[keys[m]] - this.start[keys[m]],
								};
							}
							else {
								this.initVals[t][keys[m]] = {
									start: this.currentTargets[t].get([keys[m]]),
									change: (this.reverse) ? -this.end[keys[m]] : this.end[keys[m]],
								};
							}
						}
					}
				}
				this.startTime = Date.now();
				my.pushUnique(my.animate, this.name);
				this.active = true;
				return true;
			}
		}
		return false;
	};
	/**
Finish running a tween
@method runComplete
@return Always true
@private
**/
	my.Tween.prototype.runComplete = function() {
		for (var t = 0, tz = this.currentTargets.length; t &lt; tz; t++) {
			if (my.xt(this.currentTargets[t])) {
				this.currentTargets[t].set(this.onComplete);
			}
		}
		if (this.nextTween) {
			if (my.xt(my.animation[this.nextTween])) {
				my.animation[this.nextTween].run();
			}
		}
		else if (this.callback) {
			this.callback();
		}
		if (this.killOnComplete) {
			this.kill();
		}
		return true;
	};
	/**
Stop a tween animation
@method halt
@return Always true
**/
	my.Tween.prototype.halt = function() {
		this.active = false;
		my.removeItem(my.animate, this.name);
		return true;
	};
	/**
Remove this tween from the scrawl library
@method kill
@return Always true
**/
	my.Tween.prototype.kill = function() {
		if (this.active) {
			for (var t = 0, tz = this.currentTargets.length; t &lt; tz; t++) {
				if (my.xt(this.currentTargets[t])) {
					this.currentTargets[t].set(this.onComplete);
				}
			}
		}
		my.removeItem(my.animate, this.name);
		my.removeItem(my.animationnames, this.name);
		delete my.animation[this.name];
		return true;
	};

	return my;
}(scrawl));

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
