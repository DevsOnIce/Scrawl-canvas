<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>source\scrawlPhrase.js - scrawl-canvas</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title="scrawl-canvas"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 5.0.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/Action.html">Action</a></li>
            
                <li><a href="../classes/Animation.html">Animation</a></li>
            
                <li><a href="../classes/Base.html">Base</a></li>
            
                <li><a href="../classes/Block.html">Block</a></li>
            
                <li><a href="../classes/BlurFilter.html">BlurFilter</a></li>
            
                <li><a href="../classes/BrightnessFilter.html">BrightnessFilter</a></li>
            
                <li><a href="../classes/Cell.html">Cell</a></li>
            
                <li><a href="../classes/ChannelsFilter.html">ChannelsFilter</a></li>
            
                <li><a href="../classes/ChannelStepFilter.html">ChannelStepFilter</a></li>
            
                <li><a href="../classes/Color.html">Color</a></li>
            
                <li><a href="../classes/Context.html">Context</a></li>
            
                <li><a href="../classes/Design.html">Design</a></li>
            
                <li><a href="../classes/Device.html">Device</a></li>
            
                <li><a href="../classes/Element.html">Element</a></li>
            
                <li><a href="../classes/ElementGroup.html">ElementGroup</a></li>
            
                <li><a href="../classes/Entity.html">Entity</a></li>
            
                <li><a href="../classes/Filter.html">Filter</a></li>
            
                <li><a href="../classes/Force.html">Force</a></li>
            
                <li><a href="../classes/Frame.html">Frame</a></li>
            
                <li><a href="../classes/FramePoint.html">FramePoint</a></li>
            
                <li><a href="../classes/Gradient.html">Gradient</a></li>
            
                <li><a href="../classes/GreyscaleFilter.html">GreyscaleFilter</a></li>
            
                <li><a href="../classes/Group.html">Group</a></li>
            
                <li><a href="../classes/Image.html">Image</a></li>
            
                <li><a href="../classes/InvertFilter.html">InvertFilter</a></li>
            
                <li><a href="../classes/LeachFilter.html">LeachFilter</a></li>
            
                <li><a href="../classes/Link.html">Link</a></li>
            
                <li><a href="../classes/MatrixFilter.html">MatrixFilter</a></li>
            
                <li><a href="../classes/NoiseFilter.html">NoiseFilter</a></li>
            
                <li><a href="../classes/Pad.html">Pad</a></li>
            
                <li><a href="../classes/PageElement.html">PageElement</a></li>
            
                <li><a href="../classes/Particle.html">Particle</a></li>
            
                <li><a href="../classes/Path.html">Path</a></li>
            
                <li><a href="../classes/Pattern.html">Pattern</a></li>
            
                <li><a href="../classes/Phrase.html">Phrase</a></li>
            
                <li><a href="../classes/Picture.html">Picture</a></li>
            
                <li><a href="../classes/PixelateFilter.html">PixelateFilter</a></li>
            
                <li><a href="../classes/Point.html">Point</a></li>
            
                <li><a href="../classes/Position.html">Position</a></li>
            
                <li><a href="../classes/Quaternion.html">Quaternion</a></li>
            
                <li><a href="../classes/RadialGradient.html">RadialGradient</a></li>
            
                <li><a href="../classes/SaturationFilter.html">SaturationFilter</a></li>
            
                <li><a href="../classes/SeparateFilter.html">SeparateFilter</a></li>
            
                <li><a href="../classes/Shape.html">Shape</a></li>
            
                <li><a href="../classes/Spring.html">Spring</a></li>
            
                <li><a href="../classes/SpriteAnimation.html">SpriteAnimation</a></li>
            
                <li><a href="../classes/Stack.html">Stack</a></li>
            
                <li><a href="../classes/Text.html">Text</a></li>
            
                <li><a href="../classes/ThresholdFilter.html">ThresholdFilter</a></li>
            
                <li><a href="../classes/Timeline.html">Timeline</a></li>
            
                <li><a href="../classes/TintFilter.html">TintFilter</a></li>
            
                <li><a href="../classes/Tween.html">Tween</a></li>
            
                <li><a href="../classes/Vector.html">Vector</a></li>
            
                <li><a href="../classes/Video.html">Video</a></li>
            
                <li><a href="../classes/Wheel.html">Wheel</a></li>
            
                <li><a href="../classes/window.scrawl.html">window.scrawl</a></li>
            
                <li><a href="../classes/window.scrawl_Animation.html">window.scrawl_Animation</a></li>
            
                <li><a href="../classes/window.scrawl_Block.html">window.scrawl_Block</a></li>
            
                <li><a href="../classes/window.scrawl_Collisions.html">window.scrawl_Collisions</a></li>
            
                <li><a href="../classes/window.scrawl_Color.html">window.scrawl_Color</a></li>
            
                <li><a href="../classes/window.scrawl_Factories.html">window.scrawl_Factories</a></li>
            
                <li><a href="../classes/window.scrawl_Filters.html">window.scrawl_Filters</a></li>
            
                <li><a href="../classes/window.scrawl_Frame.html">window.scrawl_Frame</a></li>
            
                <li><a href="../classes/window.scrawl_Images.html">window.scrawl_Images</a></li>
            
                <li><a href="../classes/window.scrawl_Path.html">window.scrawl_Path</a></li>
            
                <li><a href="../classes/window.scrawl_Phrase.html">window.scrawl_Phrase</a></li>
            
                <li><a href="../classes/window.scrawl_Physics.html">window.scrawl_Physics</a></li>
            
                <li><a href="../classes/window.scrawl_SaveLoad.html">window.scrawl_SaveLoad</a></li>
            
                <li><a href="../classes/window.scrawl_Shape.html">window.scrawl_Shape</a></li>
            
                <li><a href="../classes/window.scrawl_Stacks.html">window.scrawl_Stacks</a></li>
            
                <li><a href="../classes/window.scrawl_Wheel.html">window.scrawl_Wheel</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="../modules/scrawlAnimation.html">scrawlAnimation</a></li>
            
                <li><a href="../modules/scrawlBlock.html">scrawlBlock</a></li>
            
                <li><a href="../modules/scrawlCollisions.html">scrawlCollisions</a></li>
            
                <li><a href="../modules/scrawlColor.html">scrawlColor</a></li>
            
                <li><a href="../modules/scrawlCore.html">scrawlCore</a></li>
            
                <li><a href="../modules/scrawlFilters.html">scrawlFilters</a></li>
            
                <li><a href="../modules/scrawlFrame.html">scrawlFrame</a></li>
            
                <li><a href="../modules/scrawlImages.html">scrawlImages</a></li>
            
                <li><a href="../modules/scrawlPath.html">scrawlPath</a></li>
            
                <li><a href="../modules/scrawlPathFactories.html">scrawlPathFactories</a></li>
            
                <li><a href="../modules/scrawlPhrase.html">scrawlPhrase</a></li>
            
                <li><a href="../modules/scrawlPhysics.html">scrawlPhysics</a></li>
            
                <li><a href="../modules/scrawlSaveLoad.html">scrawlSaveLoad</a></li>
            
                <li><a href="../modules/scrawlShape.html">scrawlShape</a></li>
            
                <li><a href="../modules/scrawlStacks.html">scrawlStacks</a></li>
            
                <li><a href="../modules/scrawlWheel.html">scrawlWheel</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: source\scrawlPhrase.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
//---------------------------------------------------------------------------------
// The MIT License (MIT)
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
//---------------------------------------------------------------------------------

/**
# scrawlPhrase

## Purpose and features

The Phrase module adds Phrase entitys - single and multi-line text objects - to the core module

* Defines text objects for displaying on a Cell&#x27;s canvas
* Handles all related font functionality
* Performs text drawing operations on canvases

@module scrawlPhrase
**/

if (window.scrawl &amp;&amp; window.scrawl.work.extensions &amp;&amp; !window.scrawl.contains(window.scrawl.work.extensions, &#x27;phrase&#x27;)) {
	var scrawl = (function(my) {
		&#x27;use strict&#x27;;

		/**
# window.scrawl

scrawlPhrase module adaptions to the Scrawl library object

## New library sections

* scrawl.text 

@class window.scrawl_Phrase
**/

		/**
Alias for makePhrase()
@method newPhrase
@deprecated
**/
		my.newPhrase = function(items) {
			return my.makePhrase(items);
		};
		/**
A __factory__ function to generate new Phrase entitys
@method makePhrase
@param {Object} items Key:value Object argument for setting attributes
@return Phrase object
@example
	scrawl.makePhrase({
		startX: 50,
		startY: 20,
		fillStyle: &#x27;red&#x27;,
		font: &#x27;20pt Arial, sans-serif&#x27;,
		textAlign: &#x27;center&#x27;,
		text: &#x27;Hello, world!\nHow are you today?&#x27;,
		});
**/
		my.makePhrase = function(items) {
			return new my.Phrase(items);
		};
		my.pushUnique(my.work.sectionlist, &#x27;text&#x27;);
		my.pushUnique(my.work.nameslist, &#x27;textnames&#x27;);

		/**
# Phrase

## Instantiation

* scrawl.makePhrase()

## Purpose

* Defines text objects for displaying on a Cell&#x27;s canvas
* Handles all related font functionality
* Performs text drawing operations on canvases

## Access

* scrawl.entity.PHRASENAME - for the Phrase entity object

@class Phrase
@constructor
@extends Entity
@param {Object} [items] Key:value Object argument for setting attributes
**/
		my.Phrase = function Phrase(items) {
			items = my.safeObject(items);
			my.Entity.call(this, items);
			my.Position.prototype.set.call(this, items);
			this.registerInLibrary();
			this.texts = [];
			this.lineHeight = my.xtGet(items.lineHeight, my.work.d.Phrase.lineHeight);
			if (items.font) {
				this.checkFont(items.font);
			}
			else {
				this.constructFont();
			}
			this.size = this.get(&#x27;size&#x27;);
			this.multiline();
			this.getMetrics();
			return this;
		};
		my.Phrase.prototype = Object.create(my.Entity.prototype);
		/**
@property type
@type String
@default &#x27;Phrase&#x27;
@final
**/
		my.Phrase.prototype.type = &#x27;Phrase&#x27;;
		my.Phrase.prototype.classname = &#x27;entitynames&#x27;;
		my.work.d.Phrase = {
			/**
Text string to be displayed - for multiline text, insert __\n__ where the text line breaks
@property text
@type String
@default &#x27;&#x27;
**/
			text: &#x27;&#x27;,
			/**
Font style property - any permitted CSS style String (eg &#x27;italic&#x27;)
@property style
@type String
@default &#x27;normal&#x27;
**/
			style: &#x27;normal&#x27;,
			/**
Font variant property - any permitted CSS variant String (eg &#x27;small-caps&#x27;)
@property variant
@type String
@default &#x27;normal&#x27;
**/
			variant: &#x27;normal&#x27;,
			/**
Font weight property - any permitted CSS weight String or number (eg &#x27;bold&#x27;, 700)
@property weight
@type String
@default &#x27;normal&#x27;
**/
			weight: &#x27;normal&#x27;,
			/**
Font size
@property size
@type Number
@default 12
**/
			size: 12,
			/**
Font metrics property - any permitted CSS metrics String (eg &#x27;pt&#x27;, &#x27;px&#x27;)
@property metrics
@type String
@default &#x27;pt&#x27;
**/
			metrics: &#x27;pt&#x27;,
			/**
Font family property - any permitted CSS font family String

_Note: a font needs to be pre-loaded by the web page before the &amp;lt;canvas&amp;gt; element can successfully use it_
@property family
@type String
@default &#x27;sans-serif&#x27;
**/
			family: &#x27;sans-serif&#x27;,
			/**
Multiline text - line height
@property lineHeight
@type Number
@default 1.5
**/
			lineHeight: 1.5,
			/**
Background color - any permitted CSS Color string
@property backgroundColor
@type String
@default &#x27;&#x27;
**/
			backgroundColor: &#x27;&#x27;,
			/**
Background margin - additional padding around the text (in pixels), colored in by the background color
@property backgroundMargin
@type Number
@default 0
**/
			backgroundMargin: 0,
			/**
Text along path parameter - when placing text along a path, the text can be positioned in phrase blocks, word blocks or by individual letters. Permitted values: &#x27;phrase&#x27;, &#x27;word&#x27;, &#x27;glyph&#x27; (for individual letters)

_Note: the __path__ module needs to be added to the core to use this functionality_
@property textAlongPath
@type String
@default &#x27;phrase&#x27;
**/
			textAlongPath: &#x27;phrase&#x27;,
			/**
Fixed width attribute for text along path. When using fixed width (monospace) fonts, set this flag to true for faster rendering

_Note: the __path__ module needs to be added to the core to use this functionality_
@property fixedWidth
@type Boolean
@default false
**/
			fixedWidth: false,
			/**
Array of TEXTNANE strings

Users should never interfere with Text objects, as they are destroyed and recreated after every Phrase.set() and Phrase.setDelta() function call
@property texts
@type Array
@default []
@private
**/
			texts: [],
		};
		my.mergeInto(my.work.d.Phrase, my.work.d.Entity);
		/**
Augments Entity.set()

Allows users to:
* alter the font either by the font attribute, or by individual font content attributes
* update the text
* change other Entity and Phrase object attributes
@method set
@param {Object} items Object consisting of key:value attributes
@return This
@chainable
**/
		my.Phrase.prototype.set = function(items) {
			var xt = my.xt;
			my.Entity.prototype.set.call(this, items);
			items = my.safeObject(items);
			if (my.xto(items.text, items.size, items.scale, items.font, items.style, items.variant, items.metrics, items.family, items.lineHeight)) {
				this.currentHandle.flag = false;
				if (xt(items.lineHeight)) {
					this.lineHeight = items.lineHeight;
				}
				if (items.font) {
					this.checkFont(items.font);
				}
				else {
					this.constructFont();
				}
				if (xt(items.text)) {
					this.multiline(items.text);
				}
			}
			this.getMetrics();
			return this;
		};
		/**
Augments Entity.detDelta()
@method setDelta
@param {Object} items Object consisting of key:value attributes
@return This
@chainable
**/
		my.Phrase.prototype.setDelta = function(items) {
			var xt = my.xt;
			my.Entity.prototype.setDelta.call(this, items);
			items = my.safeObject(items);
			if (my.xto(items.text, items.size, items.scale, items.font, items.style, items.variant, items.metrics, items.family, items.lineHeight)) {
				this.currentHandle.flag = false;
				if (xt(items.lineHeight)) {
					this.lineHeight += items.lineHeight;
				}
				if (items.font) {
					this.checkFont(items.font);
				}
				else {
					this.constructFont();
				}
				if (xt(items.text)) {
					this.multiline(items.text);
				}
			}
			this.getMetrics();
			return this;
		};
		/**
Augments Entity.clone()
@method clone
@param {Object} items Object consisting of key:value attributes, used to update the clone&#x27;s attributes with new values
@return Cloned object
@chainable
**/
		my.Phrase.prototype.clone = function(items) {
			items.texts = [];
			return my.Entity.prototype.clone.call(this, items);
		};
		/**
Helper function - creates Text objects for each line of text in a multiline Phrase
@method multiline
@param {Object} items Object consisting of key:value attributes
@return This
@chainable
@private
**/
		my.Phrase.prototype.multiline = function(newtext) {
			var text,
				textArray,
				textnames = my.textnames,
				texts = this.texts,
				items = {},
				ri = my.removeItem,
				T = my.Text,
				i,
				iz,
				j,
				jz;
			text = &#x27;&#x27; + my.xtGet(newtext, this.text);
			textArray = text.split(&#x27;\n&#x27;);
			if (my.xt(texts)) {
				for (i = 0, iz = texts.length; i &lt; iz; i++) {
					delete my.text[texts[i]];
					ri(textnames, texts[i]);
				}
			}
			texts.length = 0;
			items.phrase = this.name;
			for (j = 0, jz = textArray.length; j &lt; jz; j++) {
				items.text = textArray[j];
				if (items.text.length &gt; 0) {
					new T(items);
				}
			}
			this.text = text;
			return this;
		};
		/**
Helper function - checks to see if font needs to be (re)constructed from its parts
@method checkFont
@param {Object} items Object consisting of key:value attributes
@return This
@chainable
@private
**/
		my.Phrase.prototype.checkFont = function(item) {
			if (my.xt(item)) {
				this.deconstructFont();
			}
			return this;
		};
		/**
Helper function - creates font-related attributes from entity&#x27;s Context object&#x27;s font attribute
@method deconstructFont
@param {Object} items Object consisting of key:value attributes
@return This
@chainable
@private
**/
		my.Phrase.prototype.deconstructFont = function() {
			var i,
				iz,
				myFont,
				res = [],
				exclude = [100, 200, 300, 400, 500, 600, 700, 800, 900, &#x27;italic&#x27;, &#x27;oblique&#x27;, &#x27;small-caps&#x27;, &#x27;bold&#x27;, &#x27;bolder&#x27;, &#x27;lighter&#x27;, &#x27;xx-small&#x27;, &#x27;x-small&#x27;, &#x27;small&#x27;, &#x27;medium&#x27;, &#x27;large&#x27;, &#x27;x-large&#x27;, &#x27;xx-large&#x27;],
				myFamily,
				myFontArray,
				style,
				variant,
				weight,
				size,
				metrics,
				family,
				d = my.work.d.Phrase,
				get = my.xtGet;
			myFont = my.ctx[this.context].font;
			style = get(this.style, d.style);
			variant = get(this.variant, d.variant);
			weight = get(this.weight, d.weight);
			size = get(this.size, d.size);
			metrics = get(this.metrics, d.metrics);
			family = get(this.family, d.family);
			if (/italic/i.test(myFont)) {
				style = &#x27;italic&#x27;;
			}
			else if (/oblique/i.test(myFont)) {
				style = &#x27;oblique&#x27;;
			}
			else {
				style = &#x27;normal&#x27;;
			}
			if (/small-caps/i.test(myFont)) {
				variant = &#x27;small-caps&#x27;;
			}
			else {
				variant = &#x27;normal&#x27;;
			}
			if (/bold/i.test(myFont)) {
				weight = &#x27;bold&#x27;;
			}
			else if (/bolder/i.test(myFont)) {
				weight = &#x27;bolder&#x27;;
			}
			else if (/lighter/i.test(myFont)) {
				weight = &#x27;lighter&#x27;;
			}
			else if (/([1-9]00)/i.test(myFont)) {
				res = myFont.match(/([1-9]00)/i);
				weight = res[1];
			}
			else {
				weight = &#x27;normal&#x27;;
			}
			res.length = 0;
			if (/(\d+)(%|in|cm|mm|em|rem|ex|pt|pc|px|vw|vh|vmin|vmax)?/i.test(myFont)) {
				res = myFont.match(/(\d+)(%|in|cm|mm|em|rem|ex|pt|pc|px|vw|vh|vmin|vmax)/i);
				size = parseFloat(res[1]);
				metrics = res[2];
			}
			else if (/xx-small/i.test(myFont)) {
				size = 3;
				metrics = &#x27;pt&#x27;;
			}
			else if (/x-small/i.test(myFont)) {
				size = 6;
				metrics = &#x27;pt&#x27;;
			}
			else if (/small/i.test(myFont)) {
				size = 9;
				metrics = &#x27;pt&#x27;;
			}
			else if (/medium/i.test(myFont)) {
				size = 12;
				metrics = &#x27;pt&#x27;;
			}
			else if (/large/i.test(myFont)) {
				size = 15;
				metrics = &#x27;pt&#x27;;
			}
			else if (/x-large/i.test(myFont)) {
				size = 18;
				metrics = &#x27;pt&#x27;;
			}
			else if (/xx-large/i.test(myFont)) {
				size = 21;
				metrics = &#x27;pt&#x27;;
			}
			else {
				size = 12;
				metrics = &#x27;pt&#x27;;
			}
			myFamily = &#x27;&#x27;;
			myFontArray = myFont.split(&#x27; &#x27;);
			for (i = 0, iz = myFontArray.length; i &lt; iz; i++) {
				if (!my.contains(exclude, myFontArray[i])) {
					if (!myFontArray[i].match(/[^\/](\d)+(%|in|cm|mm|em|rem|ex|pt|pc|px|vw|vh|vmin|vmax)?/i)) {
						myFamily += myFontArray[i] + &#x27; &#x27;;
					}
				}
			}
			if (!myFamily) {
				myFamily = this.family;
			}
			this.family = myFamily;
			this.style = style;
			this.variant = variant;
			this.weight = weight;
			this.size = size;
			this.metrics = metrics;
			this.constructFont();
			return this;
		};
		/**
Helper function - creates entity&#x27;s Context object&#x27;s phrase attribute from other font-related attributes
@method constructFont
@param {Object} items Object consisting of key:value attributes
@return This
@chainable
@private
**/
		my.Phrase.prototype.constructFont = function() {
			var myFont,
				style,
				variant,
				weight,
				size,
				metrics,
				family,
				get = my.xtGet,
				d = my.work.d.Phrase;
			myFont = &#x27;&#x27;;
			style = get(this.style, d.style);
			variant = get(this.variant, d.variant);
			weight = get(this.weight, d.weight);
			size = get(this.size, d.size);
			metrics = get(this.metrics, d.metrics);
			family = get(this.family, d.family);
			if (style !== &#x27;normal&#x27;) {
				myFont += style + &#x27; &#x27;;
			}
			if (variant !== &#x27;normal&#x27;) {
				myFont += variant + &#x27; &#x27;;
			}
			if (weight !== &#x27;normal&#x27;) {
				myFont += weight + &#x27; &#x27;;
			}
			myFont += (size * this.scale) + metrics + &#x27; &#x27;;
			myFont += family;
			my.ctx[this.context].font = myFont;
			return this;
		};
		/**
Augments Entity.stamp()
@method stamp
@param {String} [method] Permitted method attribute String; by default, will use entity&#x27;s own method setting
@param {String} [cellname] CELLNAME of cell on which entitys are to draw themselves
@param {Object} [cell] cell wrapper object
@param {Vector} [mouse] coordinates to be used for any entity currently pivoted to a mouse/touch event
@return This
@chainable
**/
		my.Phrase.prototype.stamp = function(method, cellname, cell, mouse) {
			var test;
			if (this.visibility) {
				test = (my.entity[this.path] &amp;&amp; my.entity[this.path].type === &#x27;Path&#x27;);
				if (this.pivot || !test || this.get(&#x27;textAlongPath&#x27;) === &#x27;phrase&#x27;) {
					my.Entity.prototype.stamp.call(this, method, cellname, cell, mouse);
				}
				else {
					my.text[this.texts[0]].stampAlongPath(this, method, cellname, cell);
					this.stampFilter(my.context[cellname], cellname, cell);
				}
			}
			return this;
		};
		/**
Stamp helper function - perform a &#x27;clear&#x27; method draw
@method clear
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Phrase.prototype.clear = function(ctx, cellname, cell) {
			var i, iz, tX, tY,
				o = this.getOffset(),
				here = this.currentHandle,
				textY = this.size * this.lineHeight * this.scale,
				t = my.text,
				ts = this.texts;
			cell.setEngine(this);
			ctx.globalCompositeOperation = &#x27;destination-out&#x27;;
			this.rotateCell(ctx, cell);
			tX = here.x + o.x;
			for (i = 0, iz = ts.length; i &lt; iz; i++) {
				tY = here.y + (textY * i) + o.y;
				t[ts[i]].clear(ctx, cellname, cell, tX, tY);
			}
			ctx.globalCompositeOperation = my.ctx[cellname].get(&#x27;globalCompositeOperation&#x27;);
			return this;
		};
		/**
Stamp helper function - perform a &#x27;clearWithBackground&#x27; method draw
@method clearWithBackground
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Phrase.prototype.clearWithBackground = function(ctx, cellname, cell) {
			var i, iz, tX, tY,
				o = this.getOffset(),
				here = this.currentHandle,
				textY = this.size * this.lineHeight * this.scale,
				t = my.text,
				ts = this.texts;
			cell.setEngine(this);
			this.rotateCell(ctx, cell);
			tX = here.x + o.x;
			for (i = 0, iz = ts.length; i &lt; iz; i++) {
				tY = here.y + (textY * i) + o.y;
				t[ts[i]].clearWithBackground(ctx, cellname, cell, tX, tY);
			}
			return this;
		};
		/**
Stamp helper function - perform a &#x27;draw&#x27; method draw
@method draw
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Phrase.prototype.draw = function(ctx, cellname, cell) {
			var i, iz, tX, tY,
				o = this.getOffset(),
				here = this.currentHandle,
				textY = this.size * this.lineHeight * this.scale,
				t = my.text,
				ts = this.texts;
			cell.setEngine(this);
			this.rotateCell(ctx, cell);
			if (my.xt(this.backgroundColor)) {
				this.addBackgroundColor(ctx, here);
			}
			tX = here.x + o.x;
			for (i = 0, iz = ts.length; i &lt; iz; i++) {
				tY = here.y + (textY * i) + o.y;
				t[ts[i]].draw(ctx, cellname, cell, tX, tY);
			}
			return this;
		};
		/**
Stamp helper function - perform a &#x27;fill&#x27; method draw
@method fill
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Phrase.prototype.fill = function(ctx, cellname, cell) {
			var i, iz, tX, tY,
				o = this.getOffset(),
				here = this.currentHandle,
				textY = this.size * this.lineHeight * this.scale,
				t = my.text,
				ts = this.texts;
			cell.setEngine(this);
			this.rotateCell(ctx, cell);
			if (my.xt(this.backgroundColor)) {
				this.addBackgroundColor(ctx, here);
			}
			tX = here.x + o.x;
			for (i = 0, iz = ts.length; i &lt; iz; i++) {
				tY = here.y + (textY * i) + o.y;
				t[ts[i]].fill(ctx, cellname, cell, tX, tY);
			}
			return this;
		};
		/**
Stamp helper function - perform a &#x27;drawFill&#x27; method draw
@method drawFill
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Phrase.prototype.drawFill = function(ctx, cellname, cell) {
			var i, iz, tX, tY,
				o = this.getOffset(),
				here = this.currentHandle,
				textY = this.size * this.lineHeight * this.scale,
				t = my.text,
				ts = this.texts;
			cell.setEngine(this);
			this.rotateCell(ctx, cell);
			if (my.xt(this.backgroundColor)) {
				this.addBackgroundColor(ctx, here);
			}
			tX = here.x + o.x;
			for (i = 0, iz = ts.length; i &lt; iz; i++) {
				tY = here.y + (textY * i) + o.y;
				t[ts[i]].drawFill(ctx, cellname, cell, tX, tY, this);
			}
			return this;
		};
		/**
Stamp helper function - perform a &#x27;fillDraw&#x27; method draw
@method fillDraw
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Phrase.prototype.fillDraw = function(ctx, cellname, cell) {
			var i, iz, tX, tY,
				o = this.getOffset(),
				here = this.currentHandle,
				textY = this.size * this.lineHeight * this.scale,
				t = my.text,
				ts = this.texts;
			cell.setEngine(this);
			this.rotateCell(ctx, cell);
			if (my.xt(this.backgroundColor)) {
				this.addBackgroundColor(ctx, here);
			}
			tX = here.x + o.x;
			for (i = 0, iz = ts.length; i &lt; iz; i++) {
				tY = here.y + (textY * i) + o.y;
				t[ts[i]].fillDraw(ctx, cellname, cell, tX, tY, this);
			}
			return this;
		};
		/**
Stamp helper function - perform a &#x27;sinkInto&#x27; method draw
@method sinkInto
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Phrase.prototype.sinkInto = function(ctx, cellname, cell) {
			var i, iz, tX, tY,
				o = this.getOffset(),
				here = this.currentHandle,
				textY = this.size * this.lineHeight * this.scale,
				t = my.text,
				ts = this.texts;
			cell.setEngine(this);
			this.rotateCell(ctx, cell);
			if (my.xt(this.backgroundColor)) {
				this.addBackgroundColor(ctx, here);
			}
			tX = here.x + o.x;
			for (i = 0, iz = ts.length; i &lt; iz; i++) {
				tY = here.y + (textY * i) + o.y;
				t[ts[i]].sinkInto(ctx, cellname, cell, tX, tY);
			}
			return this;
		};
		/**
Stamp helper function - perform a &#x27;floatOver&#x27; method draw
@method floatOver
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Phrase.prototype.floatOver = function(ctx, cellname, cell) {
			var i, iz, tX, tY,
				o = this.getOffset(),
				here = this.currentHandle,
				textY = this.size * this.lineHeight * this.scale,
				t = my.text,
				ts = this.texts;
			cell.setEngine(this);
			this.rotateCell(ctx, cell);
			if (my.xt(this.backgroundColor)) {
				addBackgroundColor(ctx, here);
			}
			tX = here.x + o.x;
			for (i = 0, iz = ts.length; i &lt; iz; i++) {
				tY = here.y + (textY * i) + o.y;
				t[ts[i]].floatOver(ctx, cellname, cell, tX, tY);
			}
			return this;
		};
		/**
Stamp helper function - perform a &#x27;none&#x27; method draw
@method none
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Phrase.prototype.none = function(ctx, cellname, cell) {
			return this;
		};
		/**
Helper function - calculate entity&#x27;s width and height attributes, taking into account font size, scaling, etc
@method getMetrics
@param {String} cellname CELLNAME String (any &amp;lt;canvas&amp;gt; will do for this function)
@return This
@chainable
@private
**/
		my.Phrase.prototype.getMetrics = function(cellname) {
			var i,
				iz,
				h,
				w,
				t = my.text,
				ts = this.texts,
				temp;
			h = 0;
			w = 0;
			for (i = 0, iz = ts.length; i &lt; iz; i++) {
				temp = t[ts[i]];
				w = (temp.get(&#x27;width&#x27;) &gt; w) ? temp.width : w;
				h += temp.get(&#x27;height&#x27;);
			}
			this.width = w;
			this.height = h;
			return this;
		};
		/**
Drawing function - stamps a background block onto the &amp;lt;canvas&amp;gt; element
@method addBackgroundColor
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {Vector} here Start coordinates for rectangle
@return This
@chainable
@private
**/
		my.Phrase.prototype.addBackgroundColor = function(ctx, here) {
			var h,
				w,
				margin,
				topX,
				topY;
			margin = this.get(&#x27;backgroundMargin&#x27;);
			topX = here.x - margin;
			topY = here.y - margin;
			w = (this.width * this.scale) + (margin * 2);
			h = (this.height * this.scale) + (margin * 2);
			ctx.fillStyle = this.backgroundColor;
			ctx.fillRect(topX, topY, w, h);
			ctx.fillStyle = my.ctx[this.context].get(&#x27;fillStyle&#x27;);
			return this;
		};
		/**
Drawing function - get entity offset values

Returns an object with coordinates __x__ and __y__
@method getOffset
@return JavaScript object
@private
**/
		my.Phrase.prototype.getOffset = function() {
			var oX,
				oY,
				myContext,
				result = {
					x: 0,
					y: 0
				};
			myContext = my.ctx[this.context];
			oX = 0;
			oY = 0;
			switch (myContext.get(&#x27;textAlign&#x27;)) {
				case &#x27;start&#x27;:
				case &#x27;left&#x27;:
					oX = 0;
					break;
				case &#x27;center&#x27;:
					oX = (this.width / 2) * this.scale;
					break;
				case &#x27;right&#x27;:
				case &#x27;end&#x27;:
					oX = this.width * this.scale;
					break;
			}
			switch (myContext.get(&#x27;textBaseline&#x27;)) {
				case &#x27;top&#x27;:
					oY = 0;
					break;
				case &#x27;hanging&#x27;:
					oY = this.size * this.lineHeight * this.scale * 0.1;
					break;
				case &#x27;middle&#x27;:
					oY = this.size * this.lineHeight * this.scale * 0.5;
					break;
				case &#x27;bottom&#x27;:
					oY = this.size * this.lineHeight * this.scale;
					break;
				default:
					oY = this.size * this.lineHeight * this.scale * 0.85;
			}
			result.x = oX;
			result.y = oY;
			return result;
		};
		/**
Calculate the box position of the entity

Returns an object with the following attributes:

* __left__ - x coordinate of top-left corner of the enclosing box relative to the current cell&#x27;s top-left corner
* __top__ - y coordinate of top-left corner of the enclosing box relative to the current cell&#x27;s top-left corner
* __bottom__ - x coordinate of bottom-right corner of the enclosing box relative to the current cell&#x27;s top-left corner
* __left__ - y coordinate of bottom-right corner of the enclosing box relative to the current cell&#x27;s top-left corner

@method getMaxDimensions
@param {Object} cell object
@param {Object} entity object
@return dimensions object
@private
**/
		my.Phrase.prototype.getMaxDimensions = function(cell) {
			this.maxDimensions.top = 0;
			this.maxDimensions.bottom = cell.actualHeight;
			this.maxDimensions.left = 0;
			this.maxDimensions.right = cell.actualWidth;
			this.maxDimensions.flag = false;
			return this.maxDimensions;
		};

		/**
# Text

## Instantiation

* This object should never be instantiated by users
* Objects created via Phrase object

## Purpose

* Display single lines of text within a Phrase, or along a Shape path
* Each time the Phrase object text changes, the associated Text objects are destroyed and regenerated from scratch

@class Text
@constructor
@extends Base
@param {Object} [items] Key:value Object argument for setting attributes
@private
**/
		my.Text = function Text(items) {
			var get = my.xtGet,
			pu = my.pushUnique,
			d = my.work.d.Text,
			e;
			items = my.safeObject(items);
			my.Base.call(this, items);
			this.text = get(items.text, d.text);
			this.phrase = get(items.phrase, d.phrase);
			e = my.entity[this.phrase];
			this.context = e.context;
			this.fixedWidth = get(items.fixedWidth, d.fixedWidth);
			this.textAlongPath = get(items.textAlongPath, d.textAlongPath);
			this.glyphs = [];
			this.glyphWidths = [];
			my.text[this.name] = this;
			my.pushUnique(my.textnames, this.name);
			my.pushUnique(e.texts, this.name);
			this.getMetrics();
			return this;
		};
		my.Text.prototype = Object.create(my.Base.prototype);
		/**
@property type
@type String
@default &#x27;Text&#x27;
@final
**/
		my.Text.prototype.type = &#x27;Text&#x27;;
		my.Text.prototype.classname = &#x27;textnames&#x27;;
		my.work.d.Text = {
			/**
Text to be displayed
@property text
@type String
@default &#x27;&#x27;
@private
**/
			text: &#x27;&#x27;,
			/**
PHRASENAME String of parent Phrase object
@property phrase
@type String
@default &#x27;&#x27;
@private
**/
			phrase: &#x27;&#x27;,
			/**
CTXNAME String of parent Phrase object&#x27;s Context object
@property context
@type String
@default &#x27;&#x27;
@private
**/
			context: &#x27;&#x27;,
			/**
fixedWidth value of parent Phrase object
@property fixedWidth
@type Boolean
@default false
@private
**/
			fixedWidth: false,
			/**
Text along path value of parent Phrase object
@property textAlongPath
@type String
@default &#x27;phrase&#x27;
@private
**/
			textAlongPath: &#x27;phrase&#x27;,
			/**
Text line width, accounting for font, scale, etc
@property width
@type Number
@default 0
@private
**/
			width: 0,
			/**
Text line height, accounting for font, scale, lineHeight, etc
@property height
@type Number
@default 0
@private
**/
			height: 0,
			/**
Glyphs array
@property glyphs
@type Array
@default []
@private
**/
			glyphs: [],
			/**
Glyph widths array
@property glyphWidths
@type Array
@default []
@private
**/
			glyphWidths: [],
		};
		my.mergeInto(my.work.d.Text, my.work.d.Base);
		/**
Stamp function - stamp phrases, words or individual glyphs (letters and spaces) along a Shape entity path

Permitted methods include:

* &#x27;draw&#x27; - stroke the entity&#x27;s path with the entity&#x27;s strokeStyle color, pattern or gradient
* &#x27;fill&#x27; - fill the entity&#x27;s path with the entity&#x27;s fillStyle color, pattern or gradient
* &#x27;drawFill&#x27; - stroke, and then fill, the entity&#x27;s path; if a shadow offset is present, the shadow is added only to the stroke action
* &#x27;fillDraw&#x27; - fill, and then stroke, the entity&#x27;s path; if a shadow offset is present, the shadow is added only to the fill action
* &#x27;floatOver&#x27; - stroke, and then fill, the entity&#x27;s path; shadow offset is added to both actions
* &#x27;sinkInto&#x27; - fill, and then stroke, the entity&#x27;s path; shadow offset is added to both actions
* &#x27;clear&#x27; - fill the entity&#x27;s path with transparent color &#x27;rgba(0, 0, 0, 0)&#x27;
* &#x27;clearWithBackground&#x27; - fill the entity&#x27;s path with the Cell&#x27;s current backgroundColor
* &#x27;clip&#x27; - clip the drawing zone to the entity&#x27;s path (not tested)
* &#x27;none&#x27; - perform all necessary updates, but do not draw the entity onto the canvas
@method stampAlongPath
@param {String} [method] Permitted method attribute String; by default, will use entity&#x27;s own method setting
@param {String} [cell] CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@return This
@chainable
@private
**/
		my.Text.prototype.stampAlongPath = function(p, method, cellname, cell) {
			var engine,
				here,
				pathLength,
				width,
				ratio,
				pos,
				nowPos,
				oldText,
				x,
				y,
				r,
				i,
				iz,
				g,
				gw,
				xt = my.xt,
				e = my.entity,
				between = my.isBetween,
				rad = my.work.radian;
			method = (method.substring) ? method : p.method;
			engine = my.context[cellname];
			pathLength = my.entity[p.path].getPerimeterLength();
			width = this.width * p.scale;
			ratio = width / pathLength;
			pos = p.pathPlace;
			oldText = this.text;
			if (this.glyphs.length === 0) {
				this.getMetrics();
			}
			cell.setEngine(p);
			g = this.glyphs;
			gw = this.glyphWidths;
			for (i = 0, iz = g.length; i &lt; iz; i++) {
				if (xt(g[i])) {
					this.text = g[i];
					nowPos = pos + (((gw[i] / 2) / width) * ratio);
					if (!between(nowPos, 0, 1, true)) {
						nowPos += (nowPos &gt; 0.5) ? -1 : 1;
					}
					here = e[p.path].getPerimeterPosition(nowPos, p.pathSpeedConstant, true);
					x = here.x;
					y = here.y;
					r = here.r * rad;
					engine.setTransform(1, 0, 0, 1, 0, 0);
					engine.translate(x, y);
					engine.rotate(r);
					engine.translate(-x, -y);
					this[method](engine, cellname, cell, x, y, p);
					pos += (gw[i] / width) * ratio;
					if (!between(pos, 0, 1, true)) {
						pos += (pos &gt; 0.5) ? -1 : 1;
					}
				}
			}
			this.text = oldText;
			return this;
		};
		/**
Filter function - prepare the clip for the filter
@method clipAlongPath
@return This
@chainable
@private
**/
		my.Text.prototype.clipAlongPath = function(p) {
			var engine,
				here,
				pathLength,
				width,
				ratio,
				pos,
				nowPos,
				oldText,
				x,
				y,
				r,
				i,
				iz,
				g,
				gw,
				xt = my.xt,
				e = my.entity,
				between = my.isBetween,
				method = &#x27;floatOver&#x27;,
				rad = my.work.radian;
			engine = my.work.cvx;
			pathLength = my.entity[p.path].getPerimeterLength();
			width = this.width * p.scale;
			ratio = width / pathLength;
			pos = p.pathPlace;
			oldText = this.text;
			if (this.glyphs.length === 0) {
				this.getMetrics();
			}
			g = this.glyphs;
			gw = this.glyphWidths;
			for (i = 0, iz = g.length; i &lt; iz; i++) {
				if (xt(g[i])) {
					this.text = g[i];
					nowPos = pos + (((gw[i] / 2) / width) * ratio);
					if (!between(nowPos, 0, 1, true)) {
						nowPos += (nowPos &gt; 0.5) ? -1 : 1;
					}
					here = e[p.path].getPerimeterPosition(nowPos, p.pathSpeedConstant, true);
					x = here.x;
					y = here.y;
					r = here.r * rad;
					engine.setTransform(1, 0, 0, 1, 0, 0);
					engine.translate(x, y);
					engine.rotate(r);
					engine.translate(-x, -y);
					this[method](engine, null, null, x, y, p);
					pos += (gw[i] / width) * ratio;
					if (!between(pos, 0, 1, true)) {
						pos += (pos &gt; 0.5) ? -1 : 1;
					}
				}
			}
			this.text = oldText;
			return this;
		};
		/**
Stamp helper function - perform a &#x27;clear&#x27; method draw
@method clear
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@param {Number} x Glyph horizontal coordinate
@param {Number} y Glyph vertical coordinate
@return This
@chainable
@private
**/
		my.Text.prototype.clear = function(ctx, cellname, cell, x, y) {
			ctx.fillText(this.text, x, y);
			return this;
		};
		/**
Stamp helper function - perform a &#x27;clearWithBackground&#x27; method draw
@method clearWithBackground
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@param {Number} x Glyph horizontal coordinate
@param {Number} y Glyph vertical coordinate
@return This
@chainable
@private
**/
		my.Text.prototype.clearWithBackground = function(ctx, cellname, cell, x, y) {
			var myctx = my.ctx[cellname];
			ctx.fillStyle = cell.backgroundColor;
			ctx.globalAlpha = 1;
			ctx.fillText(this.text, x, y);
			ctx.fillStyle = myctx.fillStyle;
			ctx.globalAlpha = myctx.globalAlpha;
			return this;
		};
		/**
Stamp helper function - perform a &#x27;draw&#x27; method draw
@method draw
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@param {Number} x Glyph horizontal coordinate
@param {Number} y Glyph vertical coordinate
@return This
@chainable
@private
**/
		my.Text.prototype.draw = function(ctx, cellname, cell, x, y) {
			ctx.strokeText(this.text, x, y);
			return this;
		};
		/**
Stamp helper function - perform a &#x27;fill&#x27; method draw
@method fill
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@param {Number} x Glyph horizontal coordinate
@param {Number} y Glyph vertical coordinate
@return This
@chainable
@private
**/
		my.Text.prototype.fill = function(ctx, cellname, cell, x, y) {
			ctx.fillText(this.text, x, y);
			return this;
		};
		/**
Stamp helper function - perform a &#x27;drawFill&#x27; method draw
@method drawFill
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@param {Number} x Glyph horizontal coordinate
@param {Number} y Glyph vertical coordinate
@param {Phrase} p Parent Phrase entity object
@return This
@chainable
@private
**/
		my.Text.prototype.drawFill = function(ctx, cellname, cell, x, y, p) {
			ctx.strokeText(this.text, x, y);
			p.clearShadow(ctx, cell);
			ctx.fillText(this.text, x, y);
			p.restoreShadow(ctx, cell);
			return this;
		};
		/**
Stamp helper function - perform a &#x27;fillDraw&#x27; method draw
@method fillDraw
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@param {Number} x Glyph horizontal coordinate
@param {Number} y Glyph vertical coordinate
@param {Phrase} p Parent Phrase entity object
@return This
@chainable
@private
**/
		my.Text.prototype.fillDraw = function(ctx, cellname, cell, x, y, p) {
			ctx.fillText(this.text, x, y);
			p.clearShadow(ctx, cell);
			ctx.strokeText(this.text, x, y);
			p.restoreShadow(ctx, cell);
			return this;
		};
		/**
Stamp helper function - perform a &#x27;sinkInto&#x27; method draw
@method sinkInto
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@param {Number} x Glyph horizontal coordinate
@param {Number} y Glyph vertical coordinate
@return This
@chainable
@private
**/
		my.Text.prototype.sinkInto = function(ctx, cellname, cell, x, y) {
			ctx.fillText(this.text, x, y);
			ctx.strokeText(this.text, x, y);
			return this;
		};
		/**
Stamp helper function - perform a &#x27;floatOver&#x27; method draw
@method floatOver
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@param {Number} x Glyph horizontal coordinate
@param {Number} y Glyph vertical coordinate
@return This
@chainable
@private
**/
		my.Text.prototype.floatOver = function(ctx, cellname, cell, x, y) {
			ctx.strokeText(this.text, x, y);
			ctx.fillText(this.text, x, y);
			return this;
		};
		/**
Stamp helper function - perform a &#x27;clip&#x27; method draw
@method clip
@param {Object} ctx JavaScript context engine for Cell&#x27;s &amp;lt;canvas&amp;gt; element
@param {String} cell CELLNAME string of Cell to be drawn on; by default, will use the Cell associated with this entity&#x27;s Group object
@param {Number} x Glyph horizontal coordinate
@param {Number} y Glyph vertical coordinate
@return This
@chainable
@private
**/
		my.Text.prototype.clip = function(ctx, cellname, cell, x, y) {
			return this;
		};
		/**
Calculate metrics for each phrase, word or glyph in the glyphs array
@method getMetrics
@return This
@chainable
@private
**/
		my.Text.prototype.getMetrics = function() {
			var p,
				myContext,
				myEngine,
				tempFont,
				tempBaseline,
				tempAlign,
				myText,
				myTextWidth,
				tempText,
				i,
				iz,
				j,
				jz,
				k,
				kz;
			p = my.entity[this.phrase];
			myContext = my.work.cvx;
			myEngine = my.ctx[this.context];
			tempFont = myContext.font;
			tempBaseline = myContext.textBaseline;
			tempAlign = myContext.textAlign;
			myContext.font = myEngine.get(&#x27;font&#x27;);
			myContext.textBaseline = myEngine.get(&#x27;textBaseline&#x27;);
			myContext.textAlign = myEngine.get(&#x27;textAlign&#x27;);
			this.width = myContext.measureText(this.text).width / p.scale;
			this.height = p.size * p.lineHeight;
			if (p.path) {
				this.glyphs.length = 0;
				this.glyphWidths.length = 0;
				myText = this.text;
				if (this.textAlongPath === &#x27;word&#x27;) {
					tempText = this.text.split(&#x27; &#x27;);
					for (i = 0, iz = tempText.length; i &lt; iz; i++) {
						this.glyphs.push(tempText[i]);
						this.glyphWidths.push(myContext.measureText(tempText[i]).width);
						if (my.xt(tempText[i + 1])) {
							this.glyphs.push(&#x27; &#x27;);
							this.glyphWidths.push(myContext.measureText(&#x27; &#x27;).width);
						}
					}
				}
				else {
					myTextWidth = myContext.measureText(myText).width;
					if (this.fixedWidth) {
						for (j = 0, jz = myText.length; j &lt; jz; j++) {
							this.glyphs.push(myText[j]);
							this.glyphWidths.push(myTextWidth / jz);
						}
					}
					else {
						for (k = 1, kz = myText.length; k &lt;= kz; k++) {
							this.glyphs.push(myText[k - 1]);
							tempText = myText.substr(0, k - 1) + myText.substr(k);
							this.glyphWidths.push((myTextWidth - myContext.measureText(tempText).width));
						}
					}
				}
			}
			myContext.font = tempFont;
			myContext.textBaseline = tempBaseline;
			myContext.textAlign = tempAlign;
			return this;
		};

		return my;
	}(scrawl));
}

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
