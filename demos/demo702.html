<!DOCTYPE html>
<html>

<head>
  <title>Demo 702</title>
  <link href="css/normalize.css" rel="stylesheet" />
  <link href="css/demo.css" rel="stylesheet" />
  <style>
  canvas {
    margin: 0;
  }
  </style>
</head>

<body>
  <img id="tiles" src="img/frogger.png" class="demo702" />
  <img id="brick" src="img/brick.png" class="demo702" />
  <img id="field1" src="img/frogger-field01.png" class="demo702" />
  <img id="field2" src="img/frogger-field02.png" class="demo702" />
  <img id="field3" src="img/frogger-field03.png" class="demo702" />
  <div id="mystack" class="scrawlstack">
    <h1 id="myH1"><a href="index.html">Scrawl.js</a> - demonstration 702</h1>
    <h2 id="myH2">Scrawl.js Frogger game pastiche</h2>
    <p id="myP">Use arrow keys to move frog. Eat sensibly. Have fun!</p>
    <canvas id="mytexts" width="600" height="70"></canvas>
    <canvas id="mycanvas" width="600" height="600"></canvas>
  </div>
  <p id="testmessage"></p>
  <script src="../source/scrawlCore.js"></script>
  <script id="myscript">
  var mycode = function() {
    'use strict'
    var testTicker = Date.now(),
      testTime = testTicker,
      testNow,
      testMessage = document.getElementById('testmessage');

    //define variables
    var tPad = scrawl.pad.mytexts,
      fPad = scrawl.pad.mycanvas,
      myStack = scrawl.stack.mystack,
      myHeight = 775,
      setSize,
      resize,
      level = 1,
      score = 0,
      lives = 3,
      bonus,
      health,
      myScore,
      myLevel,
      myLives,
      myHealth,
      myBonus,
      myKill,
      myLogGroup,
      myCarGroup,
      myFrogGroup,
      scene,
      action,
      tempTile,
      tileSet = {},
      getMapTile,
      moveScene,
      moveFrog,
      checkKeyDown,
      scrollSpeed,
      scrollTime,
      scrollChoke,
      frogTime,
      frogChoke = 150,
      frogPos = {
        x: 0,
        y: 0,
      },
      tileMap,
      myFrog = null,
      map,
      mySprites = null,
      kill,
      frogOnLog,
      frogOnRoad,
      frogOnRiver,
      levelCompleted,
      makeScene,
      checkCollisions,
      startLevel;

    //add images to library
    scrawl.getImagesByClass('demo702');

    //position elements in stack, ready for responsive resizing
    myStack.set({
      width: 600,
      height: myHeight,
    });
    scrawl.element.myH1.set({
      width: 600,
      startY: 0,
    });
    scrawl.element.myH2.set({
      width: 600,
      startY: 40,
    });
    scrawl.element.myP.set({
      width: 600,
      startY: 70,
    });
    tPad.set({
      startY: 100,
    });
    fPad.set({
      startY: 170,
    });
    scrawl.renderElements();

    //use a ratio to determine size - in this example ratio is window.innerHeight vs stack height
    // - use a separate ratio for font size if text is to shrink at a different rate compared to canvases
    setSize = function() {
      var ratio = (window.innerHeight / myHeight) * 0.9;
      document.body.style.fontSize = parseInt(ratio * 100) + '%';
      myStack.scaleStack(ratio);
      scrawl.renderElements();
    };
    setSize();
    //add an event listener if resizing is to be performed dynamically
    resize = function(e) {
      setSize();
    };
    window.addEventListener('resize', resize);

    //define sprites - texts canvas
    tPad.makeCurrent();
    scrawl.cell[tPad.base].set({
      backgroundColor: 'black',
    });
    myScore = scrawl.newPhrase({
      handleX: 'center',
      handleY: 'center',
      startX: 300,
      startY: 20,
      text: 'Score: ' + score,
      method: 'fill',
      fillStyle: 'gold',
      font: '24pt Arial, sans-serif',
    });
    myLevel = myScore.clone({
      font: '18pt Arial, sans-serif',
      handleX: 'left',
      startX: 10,
      text: 'Level: ' + level,
    });
    myLives = myLevel.clone({
      handleX: 'right',
      startX: 590,
      text: 'Lives: ' + lives,
    });
    myHealth = myLives.clone({
      text: 'Health: ' + parseInt(health * 10) / 10,
      startY: 55,
    });
    myBonus = myHealth.clone({
      handleX: 'left',
      startX: 10,
      text: 'Bonus: ' + bonus,
    });
    myKill = myBonus.clone({
      handleX: 'center',
      startX: 300,
      text: '',
    });

    scrawl.newPattern({
      name: 'brick',
      image: 'brick',
    });

    fPad.makeCurrent();
    scene = scrawl.addNewCell({
      name: 'scene',
      width: 600,
      height: 2000,
      sourceX: 0,
      sourceY: 1400,
      sourceWidth: 600,
      sourceHeight: 600,
      targetX: 0,
      targetY: 0,
      targetWidth: 600,
      targetHeight: 600,
      backgroundColor: '#38b117',
    });
    action = scrawl.addNewCell({
      name: 'action',
      width: 600,
      height: 2000,
      sourceX: 0,
      sourceY: 1400,
      sourceWidth: 600,
      sourceHeight: 600,
      targetX: 0,
      targetY: 0,
      targetWidth: 600,
      targetHeight: 600,
    });
    fPad.setDrawOrder(['scene', 'action']);

    tempTile = scrawl.newBlock({
      visibility: false,
      width: 20,
      height: 20,
      group: 'scene',
    });
    tileSet.river = tempTile.clone({
      name: 'river',
      fillStyle: '#72a8e0',
      keepCopyDimensions: true,
    });
    tileSet.wall = tempTile.clone({
      name: 'wall',
      fillStyle: 'brick',
      keepCopyDimensions: true,
    });
    tileSet.field = tempTile.clone({
      name: 'field',
      fillStyle: '#38b117',
      keepCopyDimensions: true,
    });

    tempTile = scrawl.newPicture({
      visibility: false,
      width: 20,
      height: 20,
      copyWidth: 20,
      copyHeight: 20,
      group: 'scene',
      keepCopyDimensions: true,
    });
    tileSet.road = tempTile.clone({
      name: 'road',
      source: 'tiles',
      copyX: 20,
      copyY: 0,
      keepCopyDimensions: true,
    });
    tileSet.mushroom = tempTile.clone({
      name: 'mushroom',
      source: 'tiles',
      copyX: 0,
      copyY: 0,
      keepCopyDimensions: true,
    });
    tileSet.worm = tempTile.clone({
      name: 'worm',
      source: 'tiles',
      copyX: 0,
      copyY: 20,
      keepCopyDimensions: true,
    });
    tileSet.fly = tempTile.clone({
      name: 'fly',
      source: 'tiles',
      copyX: 0,
      copyY: 40,
      keepCopyDimensions: true,
    });
    tileSet.slug = tempTile.clone({
      name: 'slug',
      source: 'tiles',
      copyX: 0,
      copyY: 60,
      keepCopyDimensions: true,
    });
    tileSet.toadstool = tempTile.clone({
      name: 'toadstool',
      source: 'tiles',
      copyX: 80,
      copyY: 40,
      keepCopyDimensions: true,
    });
    tileSet.poppy = tempTile.clone({
      name: 'poppy',
      source: 'tiles',
      copyX: 60,
      copyY: 40,
      keepCopyDimensions: true,
    });
    tileSet.start = tempTile.clone({
      name: 'start',
      source: 'tiles',
      copyX: 20,
      copyY: 40,
      keepCopyDimensions: true,
    });
    tileSet.finish = tempTile.clone({
      name: 'finish',
      source: 'tiles',
      copyX: 40,
      copyY: 40,
      keepCopyDimensions: true,
    });
    tileSet.car = tempTile.clone({
      name: 'car',
      source: 'tiles',
      copyX: 40,
      copyY: 0,
      copyWidth: 40,
      width: 40,
      keepCopyDimensions: true,
    });
    tileSet.log = tempTile.clone({
      name: 'log',
      source: 'tiles',
      copyX: 20,
      copyY: 20,
      copyWidth: 80,
      width: 80,
      keepCopyDimensions: true,
    });
    tileSet.frog = tempTile.clone({
      name: 'frog',
      source: 'tiles',
      copyX: 20,
      copyY: 60,
      keepCopyDimensions: true,
    });
    scrawl.deleteSprite(tempTile.name);

    myLogGroup = scrawl.newGroup({
      name: 'logGroup',
      cell: 'action',
    });
    myCarGroup = scrawl.newGroup({
      name: 'carGroup',
      cell: 'action',
    });
    myFrogGroup = scrawl.newGroup({
      name: 'frogGroup',
      cell: 'action',
    });

    makeScene = function() {
      if (myFrog) {
        scrawl.deleteSprite(myFrog.name);
      }
      if (mySprites) {
        scrawl.deleteSprite(mySprites);
      }
      if (lives > 0) {
        myKill.text = '';
        scene.set({
          sourceY: 1400,
        });
        action.set({
          sourceY: 1400,
        });
        map = scrawl.newPicture({
          name: 'mymap',
          visibility: false,
          method: 'draw',
          source: 'field' + level,
          imageDataChannel: 'color',
        }).getImageData().forceStamp('none');
        for (var i = 0; i < 100; i++) {
          for (var j = 0; j < 30; j++) {
            var t = getMapTile(map.getImageDataValue({
              x: j,
              y: i
            }));
            tileSet[t].set({
              startX: (j * 20),
              startY: (i * 20),
            }).forceStamp();
            if (j === 0) {
              tileMap.push([]);
              if (scrawl.contains(['road', 'river'], t)) {
                var t2 = getMapTile(map.getImageDataValue({
                  x: j,
                  y: i
                }), true);
                switch (t2) {
                  case 'riverltr':
                    tileSet.log.clone({
                      group: 'logGroup',
                      visibility: true,
                      startX: parseInt(Math.random() * 600),
                      deltaX: (parseInt(Math.random() * 10) / 10) + 0.5,
                      startY: i * 20,
                      keepCopyDimensions: true,
                    });
                    break;
                  case 'riverrtl':
                    tileSet.log.clone({
                      group: 'logGroup',
                      visibility: true,
                      startX: parseInt(Math.random() * 600),
                      deltaX: -((parseInt(Math.random() * 10) / 10) + 0.5),
                      startY: i * 20,
                      keepCopyDimensions: true,
                    });
                    break;
                  case 'roadltr':
                    tileSet.car.clone({
                      group: 'carGroup',
                      visibility: true,
                      startX: parseInt(Math.random() * 600),
                      deltaX: (parseInt(Math.random() * 30) / 10) + 1,
                      startY: i * 20,
                      keepCopyDimensions: true,
                    });
                    break;
                  case 'roadrtl':
                    tileSet.car.clone({
                      group: 'carGroup',
                      visibility: true,
                      startX: parseInt(Math.random() * 600),
                      deltaX: -((parseInt(Math.random() * 30) / 10) + 1),
                      startY: i * 20,
                      keepCopyDimensions: true,
                    });
                    break;
                }
              }
            }
            tileMap[i].push(t);
            if (t === 'start') {
              myFrog = tileSet.frog.clone({
                group: 'frogGroup',
                visibility: true,
                startX: j * 20,
                startY: i * 20,
                collisionPoints: 'center',
                keepCopyDimensions: true,
              });
              frogPos.x = j;
              frogPos.y = i;
            }
          }
        }
        mySprites = scrawl.group.logGroup.sprites.concat(scrawl.group.carGroup.sprites);
      } else {
        myKill.set({
          text: 'GAME OVER'
        });
        myLives.set({
          text: ''
        });
        myLevel.set({
          text: ''
        });
        myBonus.set({
          text: ''
        });
        myHealth.set({
          text: ''
        });
      }
    };

    getMapTile = function(col, side) {
      if (side) {
        switch (col) {
          case 'rgba(136,0,0,255)':
            return 'roadltr';
            break;
          case 'rgba(255,0,0,255)':
            return 'roadrtl';
            break;
          case 'rgba(0,0,136,255)':
            return 'riverltr';
            break;
          case 'rgba(0,0,255,255)':
            return 'riverrtl';
            break;
          default:
            return false;
        }
      } else {
        switch (col) {
          case 'rgba(34,34,34,255)':
            return 'worm';
            break;
          case 'rgba(68,68,68,255)':
            return 'fly';
            break;
          case 'rgba(102,102,102,255)':
            return 'slug';
            break;
          case 'rgba(136,136,136,255)':
            return 'toadstool';
            break;
          case 'rgba(170,170,170,255)':
            return 'poppy';
            break;
          case 'rgba(204,204,204,255)':
            return 'mushroom';
            break;
          case 'rgba(255,255,255,255)':
            return 'start';
            break;
          case 'rgba(136,0,0,255)':
            return 'road';
            break;
          case 'rgba(255,0,0,255)':
            return 'road';
            break;
          case 'rgba(0,0,136,255)':
            return 'river';
            break;
          case 'rgba(0,0,255,255)':
            return 'river';
            break;
          case 'rgba(255,255,0,255)':
            return 'finish';
            break;
          case 'rgba(0,0,0,255)':
            return 'wall';
            break;
          default:
            return 'field';
        }
      }
    };

    moveScene = function() {
      if (Date.now() > scrollTime + scrollChoke) {
        scene.source.y += scrollSpeed;
        if (scene.source.y < 0) {
          scene.source.y = 0;
        }
        action.source.y += scrollSpeed;
        if (action.source.y < 0) {
          action.source.y = 0;
        }
        for (var i = 0, z = mySprites.length; i < z; i++) {
          scrawl.sprite[mySprites[i]].updateStart('x');
          if (scrawl.sprite[mySprites[i]].start.x < -80) {
            scrawl.sprite[mySprites[i]].start.x = 600;
          }
          if (scrawl.sprite[mySprites[i]].start.x > 600) {
            scrawl.sprite[mySprites[i]].start.x = -80;
          }
        }
        scrollTime = Date.now();
      }
    };

    moveFrog = function(d) {
      var moveTo,
        test;
      if (!kill && Date.now() > frogTime + frogChoke) {
        if (frogOnLog) {
          frogPos.x = Math.floor((myFrog.start.x - myFrog.handle.x) / 20);
          myFrog.set({
            order: 0,
            handleX: 0,
            handleY: 0,
            pivot: null,
          });
        }
        frogOnRiver = false;
        frogOnLog = false;
        frogOnRoad = false;
        switch (d) {
          case 'left':
            frogPos.x -= 1;
            break;
          case 'right':
            frogPos.x += 1;
            break;
          case 'up':
            frogPos.y -= 1;
            break;
          case 'down':
            frogPos.y += 1;
            break;
        }
        moveTo = tileMap[frogPos.y][frogPos.x];
        switch (moveTo) {
          case 'river':
            frogOnRiver = true;
            myKill.set({
              text: 'River'
            });
            break;
          case 'road':
            frogOnRoad = true;
            myKill.set({
              text: 'Road'
            });
            break;
          case 'mushroom':
            score += 20;
            health += 0.1;
            myKill.set({
              text: 'Mushroom: 20'
            });
            break;
          case 'worm':
            score += 50;
            myKill.set({
              text: 'Worm: 50'
            });
            break;
          case 'slug':
            score += 100;
            myKill.set({
              text: 'Slug: 100'
            });
            break;
          case 'fly':
            score += 250;
            myKill.set({
              text: 'Fly: 250'
            });
            break;
          case 'toadstool':
            health -= 2;
            myKill.set({
              text: 'Toadstool: ick'
            });
            break;
          case 'poppy':
            health -= 5;
            myKill.set({
              text: 'Poppy: ICK'
            });
            break;
          case 'finish':
            levelCompleted = true;
            break;
          case 'wall':
            switch (d) {
              case 'left':
                frogPos.x += 1;
                break;
              case 'right':
                frogPos.x -= 1;
                break;
              case 'up':
                frogPos.y += 1;
                break;
              case 'down':
                frogPos.y -= 1;
                break;
            }
            break;
          case 'start':
          case 'field':
            myKill.set({
              text: ''
            });
            break;
        }
        myFrog.set({
          startX: frogPos.x * 20,
          startY: frogPos.y * 20,
        });
        if (scrawl.contains(['mushroom', 'slug', 'fly', 'worm', 'toadstool', 'poppy'], moveTo)) {
          tileSet.field.set({
            startX: frogPos.x * 20,
            startY: frogPos.y * 20,
          }).forceStamp();
          tileMap[frogPos.y][frogPos.x] = 'field';
        }
        if (frogOnRiver) {
          test = myFrogGroup.getBetweenGroupSpriteHits(myLogGroup);
          if (test.length > 0) {
            myFrog.set({
              order: 9999,
              handleX: scrawl.sprite[test[0][1]].start.x - myFrog.start.x,
              pivot: test[0][1],
            });
            frogOnLog = true;
          } else {
            kill = true;
          }
        }
        if (!scrawl.isBetween(frogPos.x, 0, 29, true) || !scrawl.isBetween(frogPos.y, 0, 99, true)) {
          kill = true;
        }
        if (bonus > 0) {
          bonus -= 4;
        }
        if (health <= 0) {
          kill = true;
        }
        frogTime = Date.now();
      }
    };

    checkKeyDown = function(e) {
      switch (e.keyCode) {
        case 37:
          moveFrog('left');
          break;
        case 38:
          moveFrog('up');
          break;
        case 39:
          moveFrog('right');
          break;
        case 40:
          moveFrog('down');
          break;
      }
    };
    window.addEventListener('keydown', checkKeyDown, false);

    checkCollisions = function() {
      var test;
      if (frogOnLog) {
        frogPos.x = parseInt((myFrog.start.x - myFrog.handle.x) / 20);
      }
      if (!scrawl.isBetween(frogPos.x, 0, 29, true) || !scrawl.isBetween(frogPos.y, 0, 99, true)) {
        kill = true;
      }
      test = myFrogGroup.getBetweenGroupSpriteHits(myCarGroup);
      if (test.length > 0) {
        kill = true;
      }
    };

    startLevel = function() {
      if (level > 3) {
        myKill.set({
          text: 'GAME COMPLETED'
        });
      } else {
        kill = frogOnLog = frogOnRoad = frogOnRiver = levelCompleted = false;
        scrawl.clear();
        scrawl.compile();
        bonus = 3000;
        health = 10;
        scrollSpeed = -0.3;
        scrollTime = Date.now();
        scrollChoke = 20;
        frogTime = Date.now();
        frogChoke = 150;
        frogPos = {
          x: 0,
          y: 0,
        };
        tileMap = [];
        makeScene();
      }
    };

    //animation object
    scrawl.newAnimation({
      fn: function() {
        if (kill) {
          myKill.set({
            text: 'DEAD'
          });
          if (bonus > 0) {
            if (bonus > 10) {
              bonus -= 10;
            } else {
              bonus--;
            }
          } else {
            lives--;
            myLives.set({
              text: 'Lives: ' + lives
            });
            startLevel();
          }
        } else if (levelCompleted) {
          myKill.set({
            text: 'HOME'
          });
          if (bonus > 0) {
            if (bonus > 10) {
              bonus -= 10;
              score += 10;
            } else {
              bonus--;
              score++;
            }
          } else {
            level++;
            startLevel();
            myLevel.set({
              text: 'Level: ' + level
            });
          }
        } else {
          if (frogOnRoad || frogOnLog) {
            checkCollisions();
          }
          moveScene();
        }
        action.clear();
        action.compile();
        scrawl.pad.mycanvas.show();
        if (lives > 0) {
          myBonus.set({
            text: 'Bonus: ' + bonus
          });
          myHealth.set({
            text: 'Health: ' + parseInt(health * 10) / 10
          });
        }
        myScore.set({
          text: 'Score: ' + score
        });
        scrawl.pad.mytexts.render();

        testNow = Date.now();
        testTime = testNow - testTicker;
        testTicker = testNow;
        testMessage.innerHTML = 'Milliseconds per screen refresh: ' + parseInt(testTime) + '; fps: ' + parseInt(1000 / testTime);

        if (myKill.text === 'GAME OVER') {
          this.halt();
          window.removeEventListener('keydown', checkKeyDown, false);
        }
      },
    });

    startLevel();
  };

  scrawl.loadModules({
      path: '../source/js/',
      minified: false,
      modules: ['animation', 'block', 'stacks', 'phrase', 'images', 'collisions'],
      callback: function() {
        window.addEventListener('load', function() {
            scrawl.init();
            mycode();
          };
        },
      });
  </script>
</body>

</html>
